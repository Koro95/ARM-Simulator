\documentclass[a4paper, 11pt, onecolumn]{article}
\usepackage[a4paper,left=2.7cm,right=2.7cm,top=3.2cm,bottom=3.2cm]{geometry}
\usepackage[english,ngerman]{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{subcaption}
\usepackage[numbers]{natbib}
\usepackage[hyphens]{url}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{color}
\newcommand{\var}[1]{{\ttfamily#1}}% variable
% Keywords command
\providecommand{\keywords}[1]
{
  \noindent \textbf{Schlüsselwörter } #1
}

\definecolor{mygray}{rgb}{0.88,0.88,0.88}
\lstset{
 basicstyle=\ttfamily\footnotesize,
 backgroundcolor=\color{mygray},
 frame=single
}


\begin{document}
\renewcommand{\abstractname}{Kurzfassung}
    \begin{center}

        \includegraphics[width=0.33\textwidth]{data/uibk} 
        
		\LARGE
        \textbf{Exposé: ARM Simulator, Interpreter und\\Debugger als Webanwendung\\}
        
		\vspace{0.2cm}        
            
        \large
        Leopold-Franzens-Universität Innsbruck\\
        Institut für Informatik\\
		Security and Privacy Lab
		
		\vspace{0.4cm}   
		
		\Large  
        Dominik Zangerl\\
		Betreuer: Alexander Schlögl  
                
        \vspace{0.4cm}
        
        \large    
        Innsbruck, \today
           
    \end{center}
    
%\begin{abstract}
%
%Kurzfassung
%
%\keywords{Schlüsselwörter}
%
%\end{abstract}

\section{Motivation}

Das Ziel meiner Bachelorarbeit ist es eine Webanwendung zu entwickeln, mit der die ARMv5 Entwicklungsumgebung simuliert wird. ARMv5 \cite{arm:2005} wird im ersten Semester als Beispiel für eine Befehlssatzarchitektur unterrichtet. Studierende sollen ihre eigenen Programme in Assembler \cite{assembly} schreiben und diese dann auf einer ARMv5 Architektur ausführen. Diese Entwicklungsumgebung wird zurzeit mit verschiedenen Linux-Programmen simuliert. Die GNU Toolchain für die ARM Cortex-A Architektur \cite{gnutoolchain} wird für das Kompilieren und Linken der Assembler-Dateien verwendet. Das kompilierte ARM-Programm läuft dann nicht auf der Architektur des Hostrechners, sondern wird mit Hilfe des QEMU User-Space-Emulators \cite{qemu} ausgeführt. Dieser Prozess kann vereinfacht werden, indem man die Toolchain in einer virtuellen Maschine oder dem Windows Subsystem for Linux \cite{wsl} installiert und sich für die Befehlskette ein Skript schreibt.

Das größere Problem bei dieser Toolchain ist die Fehlersuche und das Debugging des Programms. Den Fehler auf eine bestimmte Instruktion oder ein Registers zurückzuführen nimmt oft die größte Zeit in Anspruch. Der ARM-Emulator kann zusammen mit dem GNU Debugger \cite{gdb}  verwendet werden, welcher auch die Inhalte der Register anzeigen kann. Dies bedeutet jedoch häufig einen großen Zeitaufwand um alles aufzusetzen. Auch das Arbeiten mit Debuggern, besonders auf der Kommandozeile, könnte vielen noch nicht geläufig sein. 

An dieser Stelle greift dieses Bachelorprojekt ein und versucht die ARMv5 Entwicklungsumgebung inklusive Debugging mit einer Webanwendung zu simulieren. Benutzer:innen schreiben den ARM-Code direkt in die Webanwendung, welcher dann auf einer simulierten CPU und simuliertem Hauptspeicher direkt im Browser ausgeführt wird. Die Inhalte der Register, des Stacks und Teile des Hauptspeichers werden dauerhaft angezeigt und helfen Benutzer:innen bei der Fehlerbehebung, da sie sofort sehen, an welcher Stelle ein ungewünschter Wert in ein Register geschrieben wird. Zusammen mit den Funktionen eines Debuggers, wie zeilenweise Abarbeitung des Codes oder setzen von Breakpoints, wird den Studierenden die zeitaufwändigste Arbeit abgenommen und sie können sich auf den wichtigen Teil konzentrieren, nämlich das Schreiben und Verstehen von ARM-Assembler Code.

\section{Technologien und Implementation}

\subsection{Technologien}

Das Backend der Anwendung wird in TypeScript geschrieben. TypeScript \cite{understandingtypescript}\cite{typescript} ist eine Programmiersprache, die auf JavaScript aufbaut und statische Typisierung und Klassen hinzufügt. Sie wurde von Microsoft entwickelt um die Schwächen von JavaScript zu umgehen. Die fehlende Typisierung in JavaScript kann bei größeren Programmen leichter zu Fehlern führen. Für die Erstellung der Webanwendung wird React verwendet. React \cite{react} ist ein Webframework von Facebook zur Erstellung von Benutzeroberflächen für JavaScript/TypeScript und funktioniert in jedem modernen Browser. Dies garantiert eine einheitliche und plattformunabhängige Darstellung der TypeScript-Applikation.

\subsection{Parser}

Zuerst benötigen wir einen Parser, der den ARM-Code der Benutzer:innen aus der Webanwendung einliest und interpretiert. Dafür verwende ich den Parser-Generator tsPEG \cite{tspeg} für TypeScript. Mit tsPEG kann eine Parsing Expression Grammatik (PEG) \cite{peg} definiert werden, die alle nötigen Instruktionen und Deklarationen von ARMv5 enthält, und daraus einen Parser generieren.

\begin{lstlisting}[caption={Beispielgrammatik mit tsPEG für die \texttt{MOV-}Instruktion mit 2 Registern und Barrel-Shifter oder Daten eines Speicherbereichs mit Label.},label={lst:grammar}]
start := inst | data

inst := inst='MOV' '[ \t]+' r1='r[0-9]+' ', ' r2='r[0-9]+' shift=barrel?
barrel := ', ' shift_type=shift_type ' #' shift_amount='[0-9]+'
shift_type := 'LSL' | 'LSR' | 'ASR' | 'ROR' | 'RRX' | 'ASL'

data := '.data\n' label='.[a-zA-Z]+' '[ \t]+' '\"' data='[a-zA-Z0-9\n]*' '\"'
\end{lstlisting}

Listing \ref{lst:grammar} zeigt ein Beispiel einer solchen Grammatik. Diese Beispielgrammatik kann eine \texttt{MOV-}Instruktion mit zwei Register und Barrel-Shifter oder das Label und die Daten eines Datenbereichs erkennen. Mit den Zuweisungen innerhalb einer Zeile, wie \glqq\texttt{r1=}\grqq{} oder \glqq\texttt{data=}\grqq, werden die geparsten Werte als Variablen in einem abstrakten Syntaxbaum (AST) gespeichert. Dabei muss auch beachtet werden, dass Operationen eine unterschiedliche Anzahl von Parametern aufweisen können. In diesem Beispiel kennzeichnet das \glqq\texttt{?}\grqq{} am Ende der dritten Zeile den optionalen Barrel-Shifter. Der Parser sollte dabei die richtige Syntax kontrollieren, die Datenbereiche und Labels einlesen und anschließend die Instruktionen in der richtigen Reihenfolge parsen. Diese können dann an die simulierte CPU weitergegeben werden, welche die Instruktionen ausführt.

\subsection{Simulator und Debugger}\label{sec:debug}

Die CPU und der Hauptspeicher werden ebenfalls mit TypeScript simuliert. Die CPU liest die einzelnen Instruktionen des Parsers und führt diese dann aus, indem es die Register verändert, vom Hauptspeicher liest bzw. in den Hauptspeicher schreibt oder etwas auf dem Terminal ausgibt. Die CPU simuliert auch die Standardfunktionen eines Debuggers. Dazu zählen das Setzen von Breakpoints, das zeilenweise Ausführen der Instruktionen, Ausführung bis zum nächsten Breakpoint oder das Ausführen einer einzelnen Subroutine. Die wichtigsten Funktionen sind in Abbildung \ref{layout} angeführt. Mit \textit{Step Into} wird die nächste Zeile ausgeführt und einer möglichen Subroutine gefolgt. Mit \textit{Step Over} wird, statt der Subroutine zu folgen, diese ausgeführt und das Programm danach wieder gestoppt. \textit{Continue} führt das Programm bis zum nächsten Breakpoint aus. Weitere Funktionen sind \textit{Pause}/\textit{Stop}, um das Programm zu pausieren bzw. im Falle einer Schleife zu beenden oder \textit{Step Return}, um das Programm bis zum Ende der Subroutine auszuführen. Zuletzt beinhaltet der Simulator noch den Zustand der Register, des Stacks und des Hauptspeichers. Diese werden nach jedem Instruktionsschritt aktualisiert und Benutzer:innen angezeigt.

\subsection{Frontend}

In Abbildung \ref{layout} ist das geplante Layout der Webanwendung dargestellt, die sich an ähnlichen Online Compilern und Debuggern orientiert (Online GDB \cite{onlinegdb}, CPUlator \cite{cpulator}, emuARM \cite{emuarm}).

\begin{figure}[!htb]	
	\includegraphics[width=0.8\paperwidth]{data/layout}
	\caption{Geplantes Layout der Webanwendung mit Eingabefeld, Terminal, Ansicht für Register und Stack, Debugger und Optionsfeld. Code-Ausschnitt aus meiner Lösung für das Pascal-Dreieck.}
	\label{layout}
\end{figure}

Auf der rechten Seite befindet sich ein großes Textfeld für die Eingabe des ARM-Codes der Benutzer:innen. Bei den einzelnen Zeilennummern können Breakpoints für den Debugger gesetzt werden. Darunter befindet sich das Terminal für die Ausgabe eines Ergebnisses oder etwaigen Fehlern/Warnungen. Auf der linken Seite wird der jetzige Zustand des Programms ausgegeben, wie der Inhalt der einzelnen Register oder der Stack Trace. Der Inhalt der Register sollte an dieser Stelle auch durch die Benutzer:innen verändert werden können. Darunter befinden sich die Funktionen des Debuggers und etwaige andere Optionen, wie das Speichern und Laden von Dateien.


\section{Vorgehensweise und Zeitplan}

\begin{figure}[!htb]	
	\includegraphics[width=0.8\paperwidth]{data/timeline}
	\caption{Voraussichtliche zeitliche Planung der einzelnen Teile des Bachelorprojekts aufgeteilt in Backend, Gestalten der Benutzeroberfläche und Schreiben der Bachelorarbeit für Präsentation in diesem Semester. Andernfalls Hinzunahme der Sommermonate und Präsentation Anfang des nächsten Semesters.}
	\label{timeline}
\end{figure}

Der Zeitplan für mein Bachelorprojekt ist in Abbildung \ref{timeline} abgebildet. Da ich keine anderen Lehrveranstaltungen mehr habe und meine volle Zeit auf die Bachelorarbeit konzentrieren kann, habe ich meinen Zeitplan auf eine Präsentation in diesem Semester ausgelegt. Falls in den ersten Monaten klar wird, dass dieser Zeitplan zu eng gefasst ist und ich für eine Präsentation in diesem Semester nicht fertig werde, nehme ich die Sommermonate zur Implementation und Fertigstellung hinzu und plane die Präsentation für einen der ersten Termine des Bachelorseminars des nächsten Semesters.

Für die finale Implementierung müssen folgende Voraussetzungen erfüllt sein:

\begin{itemize}
\item Die in der Vorlesung vorgestellten bzw. für das Proseminar benötigten ARMv5-Instruktionen sind implementiert.
\item Die Webanwendung weist eine Benutzeroberfläche (ähnlich Abbildung \ref{layout}) mit Anzeige von Registern, Stack und Teilen des Hauptspeichers auf.
\item Der Debugger implementiert die in Abschnitt \ref{sec:debug} beschriebenen Funktionen.
\item Die korrekte Funktionsweise wird mit den Musterlösungen der Beispiele aus dem Proseminar getestet.
\end{itemize}
Optionale Ziele meiner Bachelorarbeit sind:

\begin{itemize}
\item Das Erstellen von Vorlagen für die PS-Aufgaben (bereitgestellte Skeletons, Code aus der Vorlesung) und Überprüfung der Korrektheit des Ergebnisses im Hintergrund (z.B. korrekte Umwandlung in Dezimalzahl, richtige Zahlen im Pascalschen Dreieck).
\item Die Implementierung einer automatischen Code-Vervollständigung mit Hinweisen zur Verwendung der eingetippten Instruktionen (Anzahl Parameter, optionale Parameter).
\end{itemize}
Der Umfang meiner Bachelorarbeit beinhaltet nicht:

\begin{itemize}
\item Die Implementierung aller Funktionen einer ARMv5-Entwicklungsumgebung (z.B. Thumb-Instruktionen, alle Exceptions).
\item Die Simulation findet auf Ebene des Assembler-Codes statt. Es gibt keine Unterstützung für die Anzeige des Maschinencodes nach der Kompilation, wie bei CPUlator \cite{cpulator}.
\end{itemize}


\bibliographystyle{plainnat}
\bibliography{literatur}

\end{document}