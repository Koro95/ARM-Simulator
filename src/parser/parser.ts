/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* start := wson start=line
* line := wso currentLine=directive wso nend nextLine=line | wso currentLine=label wso nend nextLine=line | wso currentLine=instruction wso nend nextLine=line | $
* directive := directive='.arm' | directive='.text' | directive='.data' | directive='.align' | directive='.global' ws '_start'
* label := label='[_A-Za-z]+' ':'
* instruction := instruction=art | instruction=log | instruction=copyJump
* //------------------------------------------------------------------------------------------------
* art := inst=artInst cond=condition ws operands=artOp | inst='mul' cond=condition ws operands=artMulOp | inst='mla' cond=condition ws operands=artMlaOp
* artInst := 'add' | 'adc' | 'sub' | 'sbc' | 'rsb' | 'rsc'
* artOp := artOp3 | artOp2
* artOp2 := op1=regOp ',' wso op2=op
* artOp3 := op1=regOp ',' wso op2=regOp ',' wso op3=op
* artMulOp := op1=regOp ',' wso op2=regOp ',' wso op3=regOp
* artMlaOp := op1=regOp ',' wso op2=regOp ',' wso op3=regOp ',' wso op4=regOp
* //------------------------------------------------------------------------------------------------
* log := inst=logInst cond=condition ws operands=logOp | inst=logCmpInst cond=condition ws operands=logOp2
* logInst := 'and' | 'orr' | 'eor' | 'bic'
* logCmpInst := 'cmp' | 'cmn' | 'tst' | 'teq'
* logOp := logOp3 | logOp2
* logOp2 := op1=regOp ',' wso op2=op
* logOp3 := op1=regOp ',' wso op2=regOp ',' wso op3=op
* //------------------------------------------------------------------------------------------------
* copyJump := inst=copyInst cond=condition ws operands=copyOp | inst=jumpInst1 cond=condition ws operands=jumpOp | inst=jumpInst2 cond=condition ws operands=jumpOp
* copyInst := 'mov' | 'mvn'
* jumpInst1 := 'b'
* jumpInst2 := 'bl'
* copyOp := op1=regOp ',' wso op2=op
* jumpOp := op1=branchOp
* //------------------------------------------------------------------------------------------------
* op := shiftOp=shiftOp | regImmOp=regImmOp
* regImmOp := regOp=regOp | immOp=immOp
* shiftOp := opToShift=regImmOp ',' wso shiftType=shiftType wso opShift=regImmOp
* regOp := regOp='r[0-9]+'
* immOp := immType='#' base=base number='[0-9a-f]+'
* base := '0x' | '0b' | ''
* branchOp := '[_A-Za-z0-9]+'
* shiftType := 'lsl' | 'asl' | 'lsr' | 'asr' | 'ror' | 'rrx'
* condition := condType=conditionType updateStatusReg='s'?
* conditionType := 'eq' | 'ne' | 'hs' | 'cs' | 'lo' | 'cc' | 'mi' | 'pl' | 'vs' | 'vc' | 'hi' | 'ls' | 'ge' | 'lt' | 'gt' | 'le' | 'al' | 'nv' | ''
* //------------------------------------------------------------------------------------------------
* ws := '[ \t]+'
* wso := '[ \t]*'
* wson := '[ \t\n]*'
* nend := '\n' | $
*/
type Nullable<T> = T | null;
type $$RuleType<T> = () => Nullable<T>;
interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    start = "start",
    line_1 = "line_1",
    line_2 = "line_2",
    line_3 = "line_3",
    line_4 = "line_4",
    directive_1 = "directive_1",
    directive_2 = "directive_2",
    directive_3 = "directive_3",
    directive_4 = "directive_4",
    directive_5 = "directive_5",
    label = "label",
    instruction_1 = "instruction_1",
    instruction_2 = "instruction_2",
    instruction_3 = "instruction_3",
    art_1 = "art_1",
    art_2 = "art_2",
    art_3 = "art_3",
    artInst_1 = "artInst_1",
    artInst_2 = "artInst_2",
    artInst_3 = "artInst_3",
    artInst_4 = "artInst_4",
    artInst_5 = "artInst_5",
    artInst_6 = "artInst_6",
    artOp_1 = "artOp_1",
    artOp_2 = "artOp_2",
    artOp2 = "artOp2",
    artOp3 = "artOp3",
    artMulOp = "artMulOp",
    artMlaOp = "artMlaOp",
    log_1 = "log_1",
    log_2 = "log_2",
    logInst_1 = "logInst_1",
    logInst_2 = "logInst_2",
    logInst_3 = "logInst_3",
    logInst_4 = "logInst_4",
    logCmpInst_1 = "logCmpInst_1",
    logCmpInst_2 = "logCmpInst_2",
    logCmpInst_3 = "logCmpInst_3",
    logCmpInst_4 = "logCmpInst_4",
    logOp_1 = "logOp_1",
    logOp_2 = "logOp_2",
    logOp2 = "logOp2",
    logOp3 = "logOp3",
    copyJump_1 = "copyJump_1",
    copyJump_2 = "copyJump_2",
    copyJump_3 = "copyJump_3",
    copyInst_1 = "copyInst_1",
    copyInst_2 = "copyInst_2",
    jumpInst1 = "jumpInst1",
    jumpInst2 = "jumpInst2",
    copyOp = "copyOp",
    jumpOp = "jumpOp",
    op_1 = "op_1",
    op_2 = "op_2",
    regImmOp_1 = "regImmOp_1",
    regImmOp_2 = "regImmOp_2",
    shiftOp = "shiftOp",
    regOp = "regOp",
    immOp = "immOp",
    base_1 = "base_1",
    base_2 = "base_2",
    base_3 = "base_3",
    branchOp = "branchOp",
    shiftType_1 = "shiftType_1",
    shiftType_2 = "shiftType_2",
    shiftType_3 = "shiftType_3",
    shiftType_4 = "shiftType_4",
    shiftType_5 = "shiftType_5",
    shiftType_6 = "shiftType_6",
    condition = "condition",
    conditionType_1 = "conditionType_1",
    conditionType_2 = "conditionType_2",
    conditionType_3 = "conditionType_3",
    conditionType_4 = "conditionType_4",
    conditionType_5 = "conditionType_5",
    conditionType_6 = "conditionType_6",
    conditionType_7 = "conditionType_7",
    conditionType_8 = "conditionType_8",
    conditionType_9 = "conditionType_9",
    conditionType_10 = "conditionType_10",
    conditionType_11 = "conditionType_11",
    conditionType_12 = "conditionType_12",
    conditionType_13 = "conditionType_13",
    conditionType_14 = "conditionType_14",
    conditionType_15 = "conditionType_15",
    conditionType_16 = "conditionType_16",
    conditionType_17 = "conditionType_17",
    conditionType_18 = "conditionType_18",
    conditionType_19 = "conditionType_19",
    ws = "ws",
    wso = "wso",
    wson = "wson",
    nend_1 = "nend_1",
    nend_2 = "nend_2",
    $EOF = "$EOF",
}
export interface start {
    kind: ASTKinds.start;
    start: line;
}
export type line = line_1 | line_2 | line_3 | line_4;
export interface line_1 {
    kind: ASTKinds.line_1;
    currentLine: directive;
    nextLine: line;
}
export interface line_2 {
    kind: ASTKinds.line_2;
    currentLine: label;
    nextLine: line;
}
export interface line_3 {
    kind: ASTKinds.line_3;
    currentLine: instruction;
    nextLine: line;
}
export type line_4 = {kind: ASTKinds.$EOF};
export type directive = directive_1 | directive_2 | directive_3 | directive_4 | directive_5;
export interface directive_1 {
    kind: ASTKinds.directive_1;
    directive: string;
}
export interface directive_2 {
    kind: ASTKinds.directive_2;
    directive: string;
}
export interface directive_3 {
    kind: ASTKinds.directive_3;
    directive: string;
}
export interface directive_4 {
    kind: ASTKinds.directive_4;
    directive: string;
}
export interface directive_5 {
    kind: ASTKinds.directive_5;
    directive: string;
}
export interface label {
    kind: ASTKinds.label;
    label: string;
}
export type instruction = instruction_1 | instruction_2 | instruction_3;
export interface instruction_1 {
    kind: ASTKinds.instruction_1;
    instruction: art;
}
export interface instruction_2 {
    kind: ASTKinds.instruction_2;
    instruction: log;
}
export interface instruction_3 {
    kind: ASTKinds.instruction_3;
    instruction: copyJump;
}
export type art = art_1 | art_2 | art_3;
export interface art_1 {
    kind: ASTKinds.art_1;
    inst: artInst;
    cond: condition;
    operands: artOp;
}
export interface art_2 {
    kind: ASTKinds.art_2;
    inst: string;
    cond: condition;
    operands: artMulOp;
}
export interface art_3 {
    kind: ASTKinds.art_3;
    inst: string;
    cond: condition;
    operands: artMlaOp;
}
export type artInst = artInst_1 | artInst_2 | artInst_3 | artInst_4 | artInst_5 | artInst_6;
export type artInst_1 = string;
export type artInst_2 = string;
export type artInst_3 = string;
export type artInst_4 = string;
export type artInst_5 = string;
export type artInst_6 = string;
export type artOp = artOp_1 | artOp_2;
export type artOp_1 = artOp3;
export type artOp_2 = artOp2;
export interface artOp2 {
    kind: ASTKinds.artOp2;
    op1: regOp;
    op2: op;
}
export interface artOp3 {
    kind: ASTKinds.artOp3;
    op1: regOp;
    op2: regOp;
    op3: op;
}
export interface artMulOp {
    kind: ASTKinds.artMulOp;
    op1: regOp;
    op2: regOp;
    op3: regOp;
}
export interface artMlaOp {
    kind: ASTKinds.artMlaOp;
    op1: regOp;
    op2: regOp;
    op3: regOp;
    op4: regOp;
}
export type log = log_1 | log_2;
export interface log_1 {
    kind: ASTKinds.log_1;
    inst: logInst;
    cond: condition;
    operands: logOp;
}
export interface log_2 {
    kind: ASTKinds.log_2;
    inst: logCmpInst;
    cond: condition;
    operands: logOp2;
}
export type logInst = logInst_1 | logInst_2 | logInst_3 | logInst_4;
export type logInst_1 = string;
export type logInst_2 = string;
export type logInst_3 = string;
export type logInst_4 = string;
export type logCmpInst = logCmpInst_1 | logCmpInst_2 | logCmpInst_3 | logCmpInst_4;
export type logCmpInst_1 = string;
export type logCmpInst_2 = string;
export type logCmpInst_3 = string;
export type logCmpInst_4 = string;
export type logOp = logOp_1 | logOp_2;
export type logOp_1 = logOp3;
export type logOp_2 = logOp2;
export interface logOp2 {
    kind: ASTKinds.logOp2;
    op1: regOp;
    op2: op;
}
export interface logOp3 {
    kind: ASTKinds.logOp3;
    op1: regOp;
    op2: regOp;
    op3: op;
}
export type copyJump = copyJump_1 | copyJump_2 | copyJump_3;
export interface copyJump_1 {
    kind: ASTKinds.copyJump_1;
    inst: copyInst;
    cond: condition;
    operands: copyOp;
}
export interface copyJump_2 {
    kind: ASTKinds.copyJump_2;
    inst: jumpInst1;
    cond: condition;
    operands: jumpOp;
}
export interface copyJump_3 {
    kind: ASTKinds.copyJump_3;
    inst: jumpInst2;
    cond: condition;
    operands: jumpOp;
}
export type copyInst = copyInst_1 | copyInst_2;
export type copyInst_1 = string;
export type copyInst_2 = string;
export type jumpInst1 = string;
export type jumpInst2 = string;
export interface copyOp {
    kind: ASTKinds.copyOp;
    op1: regOp;
    op2: op;
}
export interface jumpOp {
    kind: ASTKinds.jumpOp;
    op1: branchOp;
}
export type op = op_1 | op_2;
export interface op_1 {
    kind: ASTKinds.op_1;
    shiftOp: shiftOp;
}
export interface op_2 {
    kind: ASTKinds.op_2;
    regImmOp: regImmOp;
}
export type regImmOp = regImmOp_1 | regImmOp_2;
export interface regImmOp_1 {
    kind: ASTKinds.regImmOp_1;
    regOp: regOp;
}
export interface regImmOp_2 {
    kind: ASTKinds.regImmOp_2;
    immOp: immOp;
}
export interface shiftOp {
    kind: ASTKinds.shiftOp;
    opToShift: regImmOp;
    shiftType: shiftType;
    opShift: regImmOp;
}
export interface regOp {
    kind: ASTKinds.regOp;
    regOp: string;
}
export interface immOp {
    kind: ASTKinds.immOp;
    immType: string;
    base: base;
    number: string;
}
export type base = base_1 | base_2 | base_3;
export type base_1 = string;
export type base_2 = string;
export type base_3 = string;
export type branchOp = string;
export type shiftType = shiftType_1 | shiftType_2 | shiftType_3 | shiftType_4 | shiftType_5 | shiftType_6;
export type shiftType_1 = string;
export type shiftType_2 = string;
export type shiftType_3 = string;
export type shiftType_4 = string;
export type shiftType_5 = string;
export type shiftType_6 = string;
export interface condition {
    kind: ASTKinds.condition;
    condType: conditionType;
    updateStatusReg: Nullable<string>;
}
export type conditionType = conditionType_1 | conditionType_2 | conditionType_3 | conditionType_4 | conditionType_5 | conditionType_6 | conditionType_7 | conditionType_8 | conditionType_9 | conditionType_10 | conditionType_11 | conditionType_12 | conditionType_13 | conditionType_14 | conditionType_15 | conditionType_16 | conditionType_17 | conditionType_18 | conditionType_19;
export type conditionType_1 = string;
export type conditionType_2 = string;
export type conditionType_3 = string;
export type conditionType_4 = string;
export type conditionType_5 = string;
export type conditionType_6 = string;
export type conditionType_7 = string;
export type conditionType_8 = string;
export type conditionType_9 = string;
export type conditionType_10 = string;
export type conditionType_11 = string;
export type conditionType_12 = string;
export type conditionType_13 = string;
export type conditionType_14 = string;
export type conditionType_15 = string;
export type conditionType_16 = string;
export type conditionType_17 = string;
export type conditionType_18 = string;
export type conditionType_19 = string;
export type ws = string;
export type wso = string;
export type wson = string;
export type nend = nend_1 | nend_2;
export type nend_1 = string;
export type nend_2 = {kind: ASTKinds.$EOF};
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating: boolean = false;
    private memoSafe: boolean = true;
    constructor(input: string) {
        this.pos = {overallPos: 0, line: 1, offset: 0};
        this.input = input;
    }
    public reset(pos: PosInfo) {
        this.pos = pos;
    }
    public finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    public clearMemos(): void {
    }
    public matchstart($$dpth: number, $$cr?: ErrorTracker): Nullable<start> {
        return this.run<start>($$dpth,
            () => {
                let $scope$start: Nullable<line>;
                let $$res: Nullable<start> = null;
                if (true
                    && this.matchwson($$dpth + 1, $$cr) !== null
                    && ($scope$start = this.matchline($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.start, start: $scope$start};
                }
                return $$res;
            });
    }
    public matchline($$dpth: number, $$cr?: ErrorTracker): Nullable<line> {
        return this.choice<line>([
            () => this.matchline_1($$dpth + 1, $$cr),
            () => this.matchline_2($$dpth + 1, $$cr),
            () => this.matchline_3($$dpth + 1, $$cr),
            () => this.matchline_4($$dpth + 1, $$cr),
        ]);
    }
    public matchline_1($$dpth: number, $$cr?: ErrorTracker): Nullable<line_1> {
        return this.run<line_1>($$dpth,
            () => {
                let $scope$currentLine: Nullable<directive>;
                let $scope$nextLine: Nullable<line>;
                let $$res: Nullable<line_1> = null;
                if (true
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$currentLine = this.matchdirective($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.matchnend($$dpth + 1, $$cr) !== null
                    && ($scope$nextLine = this.matchline($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.line_1, currentLine: $scope$currentLine, nextLine: $scope$nextLine};
                }
                return $$res;
            });
    }
    public matchline_2($$dpth: number, $$cr?: ErrorTracker): Nullable<line_2> {
        return this.run<line_2>($$dpth,
            () => {
                let $scope$currentLine: Nullable<label>;
                let $scope$nextLine: Nullable<line>;
                let $$res: Nullable<line_2> = null;
                if (true
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$currentLine = this.matchlabel($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.matchnend($$dpth + 1, $$cr) !== null
                    && ($scope$nextLine = this.matchline($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.line_2, currentLine: $scope$currentLine, nextLine: $scope$nextLine};
                }
                return $$res;
            });
    }
    public matchline_3($$dpth: number, $$cr?: ErrorTracker): Nullable<line_3> {
        return this.run<line_3>($$dpth,
            () => {
                let $scope$currentLine: Nullable<instruction>;
                let $scope$nextLine: Nullable<line>;
                let $$res: Nullable<line_3> = null;
                if (true
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$currentLine = this.matchinstruction($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.matchnend($$dpth + 1, $$cr) !== null
                    && ($scope$nextLine = this.matchline($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.line_3, currentLine: $scope$currentLine, nextLine: $scope$nextLine};
                }
                return $$res;
            });
    }
    public matchline_4($$dpth: number, $$cr?: ErrorTracker): Nullable<line_4> {
        return this.match$EOF($$cr);
    }
    public matchdirective($$dpth: number, $$cr?: ErrorTracker): Nullable<directive> {
        return this.choice<directive>([
            () => this.matchdirective_1($$dpth + 1, $$cr),
            () => this.matchdirective_2($$dpth + 1, $$cr),
            () => this.matchdirective_3($$dpth + 1, $$cr),
            () => this.matchdirective_4($$dpth + 1, $$cr),
            () => this.matchdirective_5($$dpth + 1, $$cr),
        ]);
    }
    public matchdirective_1($$dpth: number, $$cr?: ErrorTracker): Nullable<directive_1> {
        return this.run<directive_1>($$dpth,
            () => {
                let $scope$directive: Nullable<string>;
                let $$res: Nullable<directive_1> = null;
                if (true
                    && ($scope$directive = this.regexAccept(String.raw`(?:.arm)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.directive_1, directive: $scope$directive};
                }
                return $$res;
            });
    }
    public matchdirective_2($$dpth: number, $$cr?: ErrorTracker): Nullable<directive_2> {
        return this.run<directive_2>($$dpth,
            () => {
                let $scope$directive: Nullable<string>;
                let $$res: Nullable<directive_2> = null;
                if (true
                    && ($scope$directive = this.regexAccept(String.raw`(?:.text)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.directive_2, directive: $scope$directive};
                }
                return $$res;
            });
    }
    public matchdirective_3($$dpth: number, $$cr?: ErrorTracker): Nullable<directive_3> {
        return this.run<directive_3>($$dpth,
            () => {
                let $scope$directive: Nullable<string>;
                let $$res: Nullable<directive_3> = null;
                if (true
                    && ($scope$directive = this.regexAccept(String.raw`(?:.data)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.directive_3, directive: $scope$directive};
                }
                return $$res;
            });
    }
    public matchdirective_4($$dpth: number, $$cr?: ErrorTracker): Nullable<directive_4> {
        return this.run<directive_4>($$dpth,
            () => {
                let $scope$directive: Nullable<string>;
                let $$res: Nullable<directive_4> = null;
                if (true
                    && ($scope$directive = this.regexAccept(String.raw`(?:.align)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.directive_4, directive: $scope$directive};
                }
                return $$res;
            });
    }
    public matchdirective_5($$dpth: number, $$cr?: ErrorTracker): Nullable<directive_5> {
        return this.run<directive_5>($$dpth,
            () => {
                let $scope$directive: Nullable<string>;
                let $$res: Nullable<directive_5> = null;
                if (true
                    && ($scope$directive = this.regexAccept(String.raw`(?:.global)`, $$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:_start)`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.directive_5, directive: $scope$directive};
                }
                return $$res;
            });
    }
    public matchlabel($$dpth: number, $$cr?: ErrorTracker): Nullable<label> {
        return this.run<label>($$dpth,
            () => {
                let $scope$label: Nullable<string>;
                let $$res: Nullable<label> = null;
                if (true
                    && ($scope$label = this.regexAccept(String.raw`(?:[_A-Za-z]+)`, $$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?::)`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.label, label: $scope$label};
                }
                return $$res;
            });
    }
    public matchinstruction($$dpth: number, $$cr?: ErrorTracker): Nullable<instruction> {
        return this.choice<instruction>([
            () => this.matchinstruction_1($$dpth + 1, $$cr),
            () => this.matchinstruction_2($$dpth + 1, $$cr),
            () => this.matchinstruction_3($$dpth + 1, $$cr),
        ]);
    }
    public matchinstruction_1($$dpth: number, $$cr?: ErrorTracker): Nullable<instruction_1> {
        return this.run<instruction_1>($$dpth,
            () => {
                let $scope$instruction: Nullable<art>;
                let $$res: Nullable<instruction_1> = null;
                if (true
                    && ($scope$instruction = this.matchart($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.instruction_1, instruction: $scope$instruction};
                }
                return $$res;
            });
    }
    public matchinstruction_2($$dpth: number, $$cr?: ErrorTracker): Nullable<instruction_2> {
        return this.run<instruction_2>($$dpth,
            () => {
                let $scope$instruction: Nullable<log>;
                let $$res: Nullable<instruction_2> = null;
                if (true
                    && ($scope$instruction = this.matchlog($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.instruction_2, instruction: $scope$instruction};
                }
                return $$res;
            });
    }
    public matchinstruction_3($$dpth: number, $$cr?: ErrorTracker): Nullable<instruction_3> {
        return this.run<instruction_3>($$dpth,
            () => {
                let $scope$instruction: Nullable<copyJump>;
                let $$res: Nullable<instruction_3> = null;
                if (true
                    && ($scope$instruction = this.matchcopyJump($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.instruction_3, instruction: $scope$instruction};
                }
                return $$res;
            });
    }
    public matchart($$dpth: number, $$cr?: ErrorTracker): Nullable<art> {
        return this.choice<art>([
            () => this.matchart_1($$dpth + 1, $$cr),
            () => this.matchart_2($$dpth + 1, $$cr),
            () => this.matchart_3($$dpth + 1, $$cr),
        ]);
    }
    public matchart_1($$dpth: number, $$cr?: ErrorTracker): Nullable<art_1> {
        return this.run<art_1>($$dpth,
            () => {
                let $scope$inst: Nullable<artInst>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<artOp>;
                let $$res: Nullable<art_1> = null;
                if (true
                    && ($scope$inst = this.matchartInst($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchartOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.art_1, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchart_2($$dpth: number, $$cr?: ErrorTracker): Nullable<art_2> {
        return this.run<art_2>($$dpth,
            () => {
                let $scope$inst: Nullable<string>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<artMulOp>;
                let $$res: Nullable<art_2> = null;
                if (true
                    && ($scope$inst = this.regexAccept(String.raw`(?:mul)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchartMulOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.art_2, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchart_3($$dpth: number, $$cr?: ErrorTracker): Nullable<art_3> {
        return this.run<art_3>($$dpth,
            () => {
                let $scope$inst: Nullable<string>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<artMlaOp>;
                let $$res: Nullable<art_3> = null;
                if (true
                    && ($scope$inst = this.regexAccept(String.raw`(?:mla)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchartMlaOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.art_3, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchartInst($$dpth: number, $$cr?: ErrorTracker): Nullable<artInst> {
        return this.choice<artInst>([
            () => this.matchartInst_1($$dpth + 1, $$cr),
            () => this.matchartInst_2($$dpth + 1, $$cr),
            () => this.matchartInst_3($$dpth + 1, $$cr),
            () => this.matchartInst_4($$dpth + 1, $$cr),
            () => this.matchartInst_5($$dpth + 1, $$cr),
            () => this.matchartInst_6($$dpth + 1, $$cr),
        ]);
    }
    public matchartInst_1($$dpth: number, $$cr?: ErrorTracker): Nullable<artInst_1> {
        return this.regexAccept(String.raw`(?:add)`, $$dpth + 1, $$cr);
    }
    public matchartInst_2($$dpth: number, $$cr?: ErrorTracker): Nullable<artInst_2> {
        return this.regexAccept(String.raw`(?:adc)`, $$dpth + 1, $$cr);
    }
    public matchartInst_3($$dpth: number, $$cr?: ErrorTracker): Nullable<artInst_3> {
        return this.regexAccept(String.raw`(?:sub)`, $$dpth + 1, $$cr);
    }
    public matchartInst_4($$dpth: number, $$cr?: ErrorTracker): Nullable<artInst_4> {
        return this.regexAccept(String.raw`(?:sbc)`, $$dpth + 1, $$cr);
    }
    public matchartInst_5($$dpth: number, $$cr?: ErrorTracker): Nullable<artInst_5> {
        return this.regexAccept(String.raw`(?:rsb)`, $$dpth + 1, $$cr);
    }
    public matchartInst_6($$dpth: number, $$cr?: ErrorTracker): Nullable<artInst_6> {
        return this.regexAccept(String.raw`(?:rsc)`, $$dpth + 1, $$cr);
    }
    public matchartOp($$dpth: number, $$cr?: ErrorTracker): Nullable<artOp> {
        return this.choice<artOp>([
            () => this.matchartOp_1($$dpth + 1, $$cr),
            () => this.matchartOp_2($$dpth + 1, $$cr),
        ]);
    }
    public matchartOp_1($$dpth: number, $$cr?: ErrorTracker): Nullable<artOp_1> {
        return this.matchartOp3($$dpth + 1, $$cr);
    }
    public matchartOp_2($$dpth: number, $$cr?: ErrorTracker): Nullable<artOp_2> {
        return this.matchartOp2($$dpth + 1, $$cr);
    }
    public matchartOp2($$dpth: number, $$cr?: ErrorTracker): Nullable<artOp2> {
        return this.run<artOp2>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<op>;
                let $$res: Nullable<artOp2> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchop($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.artOp2, op1: $scope$op1, op2: $scope$op2};
                }
                return $$res;
            });
    }
    public matchartOp3($$dpth: number, $$cr?: ErrorTracker): Nullable<artOp3> {
        return this.run<artOp3>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<regOp>;
                let $scope$op3: Nullable<op>;
                let $$res: Nullable<artOp3> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op3 = this.matchop($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.artOp3, op1: $scope$op1, op2: $scope$op2, op3: $scope$op3};
                }
                return $$res;
            });
    }
    public matchartMulOp($$dpth: number, $$cr?: ErrorTracker): Nullable<artMulOp> {
        return this.run<artMulOp>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<regOp>;
                let $scope$op3: Nullable<regOp>;
                let $$res: Nullable<artMulOp> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op3 = this.matchregOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.artMulOp, op1: $scope$op1, op2: $scope$op2, op3: $scope$op3};
                }
                return $$res;
            });
    }
    public matchartMlaOp($$dpth: number, $$cr?: ErrorTracker): Nullable<artMlaOp> {
        return this.run<artMlaOp>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<regOp>;
                let $scope$op3: Nullable<regOp>;
                let $scope$op4: Nullable<regOp>;
                let $$res: Nullable<artMlaOp> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op3 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op4 = this.matchregOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.artMlaOp, op1: $scope$op1, op2: $scope$op2, op3: $scope$op3, op4: $scope$op4};
                }
                return $$res;
            });
    }
    public matchlog($$dpth: number, $$cr?: ErrorTracker): Nullable<log> {
        return this.choice<log>([
            () => this.matchlog_1($$dpth + 1, $$cr),
            () => this.matchlog_2($$dpth + 1, $$cr),
        ]);
    }
    public matchlog_1($$dpth: number, $$cr?: ErrorTracker): Nullable<log_1> {
        return this.run<log_1>($$dpth,
            () => {
                let $scope$inst: Nullable<logInst>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<logOp>;
                let $$res: Nullable<log_1> = null;
                if (true
                    && ($scope$inst = this.matchlogInst($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchlogOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.log_1, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchlog_2($$dpth: number, $$cr?: ErrorTracker): Nullable<log_2> {
        return this.run<log_2>($$dpth,
            () => {
                let $scope$inst: Nullable<logCmpInst>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<logOp2>;
                let $$res: Nullable<log_2> = null;
                if (true
                    && ($scope$inst = this.matchlogCmpInst($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchlogOp2($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.log_2, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchlogInst($$dpth: number, $$cr?: ErrorTracker): Nullable<logInst> {
        return this.choice<logInst>([
            () => this.matchlogInst_1($$dpth + 1, $$cr),
            () => this.matchlogInst_2($$dpth + 1, $$cr),
            () => this.matchlogInst_3($$dpth + 1, $$cr),
            () => this.matchlogInst_4($$dpth + 1, $$cr),
        ]);
    }
    public matchlogInst_1($$dpth: number, $$cr?: ErrorTracker): Nullable<logInst_1> {
        return this.regexAccept(String.raw`(?:and)`, $$dpth + 1, $$cr);
    }
    public matchlogInst_2($$dpth: number, $$cr?: ErrorTracker): Nullable<logInst_2> {
        return this.regexAccept(String.raw`(?:orr)`, $$dpth + 1, $$cr);
    }
    public matchlogInst_3($$dpth: number, $$cr?: ErrorTracker): Nullable<logInst_3> {
        return this.regexAccept(String.raw`(?:eor)`, $$dpth + 1, $$cr);
    }
    public matchlogInst_4($$dpth: number, $$cr?: ErrorTracker): Nullable<logInst_4> {
        return this.regexAccept(String.raw`(?:bic)`, $$dpth + 1, $$cr);
    }
    public matchlogCmpInst($$dpth: number, $$cr?: ErrorTracker): Nullable<logCmpInst> {
        return this.choice<logCmpInst>([
            () => this.matchlogCmpInst_1($$dpth + 1, $$cr),
            () => this.matchlogCmpInst_2($$dpth + 1, $$cr),
            () => this.matchlogCmpInst_3($$dpth + 1, $$cr),
            () => this.matchlogCmpInst_4($$dpth + 1, $$cr),
        ]);
    }
    public matchlogCmpInst_1($$dpth: number, $$cr?: ErrorTracker): Nullable<logCmpInst_1> {
        return this.regexAccept(String.raw`(?:cmp)`, $$dpth + 1, $$cr);
    }
    public matchlogCmpInst_2($$dpth: number, $$cr?: ErrorTracker): Nullable<logCmpInst_2> {
        return this.regexAccept(String.raw`(?:cmn)`, $$dpth + 1, $$cr);
    }
    public matchlogCmpInst_3($$dpth: number, $$cr?: ErrorTracker): Nullable<logCmpInst_3> {
        return this.regexAccept(String.raw`(?:tst)`, $$dpth + 1, $$cr);
    }
    public matchlogCmpInst_4($$dpth: number, $$cr?: ErrorTracker): Nullable<logCmpInst_4> {
        return this.regexAccept(String.raw`(?:teq)`, $$dpth + 1, $$cr);
    }
    public matchlogOp($$dpth: number, $$cr?: ErrorTracker): Nullable<logOp> {
        return this.choice<logOp>([
            () => this.matchlogOp_1($$dpth + 1, $$cr),
            () => this.matchlogOp_2($$dpth + 1, $$cr),
        ]);
    }
    public matchlogOp_1($$dpth: number, $$cr?: ErrorTracker): Nullable<logOp_1> {
        return this.matchlogOp3($$dpth + 1, $$cr);
    }
    public matchlogOp_2($$dpth: number, $$cr?: ErrorTracker): Nullable<logOp_2> {
        return this.matchlogOp2($$dpth + 1, $$cr);
    }
    public matchlogOp2($$dpth: number, $$cr?: ErrorTracker): Nullable<logOp2> {
        return this.run<logOp2>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<op>;
                let $$res: Nullable<logOp2> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchop($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.logOp2, op1: $scope$op1, op2: $scope$op2};
                }
                return $$res;
            });
    }
    public matchlogOp3($$dpth: number, $$cr?: ErrorTracker): Nullable<logOp3> {
        return this.run<logOp3>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<regOp>;
                let $scope$op3: Nullable<op>;
                let $$res: Nullable<logOp3> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op3 = this.matchop($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.logOp3, op1: $scope$op1, op2: $scope$op2, op3: $scope$op3};
                }
                return $$res;
            });
    }
    public matchcopyJump($$dpth: number, $$cr?: ErrorTracker): Nullable<copyJump> {
        return this.choice<copyJump>([
            () => this.matchcopyJump_1($$dpth + 1, $$cr),
            () => this.matchcopyJump_2($$dpth + 1, $$cr),
            () => this.matchcopyJump_3($$dpth + 1, $$cr),
        ]);
    }
    public matchcopyJump_1($$dpth: number, $$cr?: ErrorTracker): Nullable<copyJump_1> {
        return this.run<copyJump_1>($$dpth,
            () => {
                let $scope$inst: Nullable<copyInst>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<copyOp>;
                let $$res: Nullable<copyJump_1> = null;
                if (true
                    && ($scope$inst = this.matchcopyInst($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchcopyOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.copyJump_1, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchcopyJump_2($$dpth: number, $$cr?: ErrorTracker): Nullable<copyJump_2> {
        return this.run<copyJump_2>($$dpth,
            () => {
                let $scope$inst: Nullable<jumpInst1>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<jumpOp>;
                let $$res: Nullable<copyJump_2> = null;
                if (true
                    && ($scope$inst = this.matchjumpInst1($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchjumpOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.copyJump_2, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchcopyJump_3($$dpth: number, $$cr?: ErrorTracker): Nullable<copyJump_3> {
        return this.run<copyJump_3>($$dpth,
            () => {
                let $scope$inst: Nullable<jumpInst2>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<jumpOp>;
                let $$res: Nullable<copyJump_3> = null;
                if (true
                    && ($scope$inst = this.matchjumpInst2($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchjumpOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.copyJump_3, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchcopyInst($$dpth: number, $$cr?: ErrorTracker): Nullable<copyInst> {
        return this.choice<copyInst>([
            () => this.matchcopyInst_1($$dpth + 1, $$cr),
            () => this.matchcopyInst_2($$dpth + 1, $$cr),
        ]);
    }
    public matchcopyInst_1($$dpth: number, $$cr?: ErrorTracker): Nullable<copyInst_1> {
        return this.regexAccept(String.raw`(?:mov)`, $$dpth + 1, $$cr);
    }
    public matchcopyInst_2($$dpth: number, $$cr?: ErrorTracker): Nullable<copyInst_2> {
        return this.regexAccept(String.raw`(?:mvn)`, $$dpth + 1, $$cr);
    }
    public matchjumpInst1($$dpth: number, $$cr?: ErrorTracker): Nullable<jumpInst1> {
        return this.regexAccept(String.raw`(?:b)`, $$dpth + 1, $$cr);
    }
    public matchjumpInst2($$dpth: number, $$cr?: ErrorTracker): Nullable<jumpInst2> {
        return this.regexAccept(String.raw`(?:bl)`, $$dpth + 1, $$cr);
    }
    public matchcopyOp($$dpth: number, $$cr?: ErrorTracker): Nullable<copyOp> {
        return this.run<copyOp>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<op>;
                let $$res: Nullable<copyOp> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchop($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.copyOp, op1: $scope$op1, op2: $scope$op2};
                }
                return $$res;
            });
    }
    public matchjumpOp($$dpth: number, $$cr?: ErrorTracker): Nullable<jumpOp> {
        return this.run<jumpOp>($$dpth,
            () => {
                let $scope$op1: Nullable<branchOp>;
                let $$res: Nullable<jumpOp> = null;
                if (true
                    && ($scope$op1 = this.matchbranchOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.jumpOp, op1: $scope$op1};
                }
                return $$res;
            });
    }
    public matchop($$dpth: number, $$cr?: ErrorTracker): Nullable<op> {
        return this.choice<op>([
            () => this.matchop_1($$dpth + 1, $$cr),
            () => this.matchop_2($$dpth + 1, $$cr),
        ]);
    }
    public matchop_1($$dpth: number, $$cr?: ErrorTracker): Nullable<op_1> {
        return this.run<op_1>($$dpth,
            () => {
                let $scope$shiftOp: Nullable<shiftOp>;
                let $$res: Nullable<op_1> = null;
                if (true
                    && ($scope$shiftOp = this.matchshiftOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.op_1, shiftOp: $scope$shiftOp};
                }
                return $$res;
            });
    }
    public matchop_2($$dpth: number, $$cr?: ErrorTracker): Nullable<op_2> {
        return this.run<op_2>($$dpth,
            () => {
                let $scope$regImmOp: Nullable<regImmOp>;
                let $$res: Nullable<op_2> = null;
                if (true
                    && ($scope$regImmOp = this.matchregImmOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.op_2, regImmOp: $scope$regImmOp};
                }
                return $$res;
            });
    }
    public matchregImmOp($$dpth: number, $$cr?: ErrorTracker): Nullable<regImmOp> {
        return this.choice<regImmOp>([
            () => this.matchregImmOp_1($$dpth + 1, $$cr),
            () => this.matchregImmOp_2($$dpth + 1, $$cr),
        ]);
    }
    public matchregImmOp_1($$dpth: number, $$cr?: ErrorTracker): Nullable<regImmOp_1> {
        return this.run<regImmOp_1>($$dpth,
            () => {
                let $scope$regOp: Nullable<regOp>;
                let $$res: Nullable<regImmOp_1> = null;
                if (true
                    && ($scope$regOp = this.matchregOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.regImmOp_1, regOp: $scope$regOp};
                }
                return $$res;
            });
    }
    public matchregImmOp_2($$dpth: number, $$cr?: ErrorTracker): Nullable<regImmOp_2> {
        return this.run<regImmOp_2>($$dpth,
            () => {
                let $scope$immOp: Nullable<immOp>;
                let $$res: Nullable<regImmOp_2> = null;
                if (true
                    && ($scope$immOp = this.matchimmOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.regImmOp_2, immOp: $scope$immOp};
                }
                return $$res;
            });
    }
    public matchshiftOp($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftOp> {
        return this.run<shiftOp>($$dpth,
            () => {
                let $scope$opToShift: Nullable<regImmOp>;
                let $scope$shiftType: Nullable<shiftType>;
                let $scope$opShift: Nullable<regImmOp>;
                let $$res: Nullable<shiftOp> = null;
                if (true
                    && ($scope$opToShift = this.matchregImmOp($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$shiftType = this.matchshiftType($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$opShift = this.matchregImmOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.shiftOp, opToShift: $scope$opToShift, shiftType: $scope$shiftType, opShift: $scope$opShift};
                }
                return $$res;
            });
    }
    public matchregOp($$dpth: number, $$cr?: ErrorTracker): Nullable<regOp> {
        return this.run<regOp>($$dpth,
            () => {
                let $scope$regOp: Nullable<string>;
                let $$res: Nullable<regOp> = null;
                if (true
                    && ($scope$regOp = this.regexAccept(String.raw`(?:r[0-9]+)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.regOp, regOp: $scope$regOp};
                }
                return $$res;
            });
    }
    public matchimmOp($$dpth: number, $$cr?: ErrorTracker): Nullable<immOp> {
        return this.run<immOp>($$dpth,
            () => {
                let $scope$immType: Nullable<string>;
                let $scope$base: Nullable<base>;
                let $scope$number: Nullable<string>;
                let $$res: Nullable<immOp> = null;
                if (true
                    && ($scope$immType = this.regexAccept(String.raw`(?:#)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$base = this.matchbase($$dpth + 1, $$cr)) !== null
                    && ($scope$number = this.regexAccept(String.raw`(?:[0-9a-f]+)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.immOp, immType: $scope$immType, base: $scope$base, number: $scope$number};
                }
                return $$res;
            });
    }
    public matchbase($$dpth: number, $$cr?: ErrorTracker): Nullable<base> {
        return this.choice<base>([
            () => this.matchbase_1($$dpth + 1, $$cr),
            () => this.matchbase_2($$dpth + 1, $$cr),
            () => this.matchbase_3($$dpth + 1, $$cr),
        ]);
    }
    public matchbase_1($$dpth: number, $$cr?: ErrorTracker): Nullable<base_1> {
        return this.regexAccept(String.raw`(?:0x)`, $$dpth + 1, $$cr);
    }
    public matchbase_2($$dpth: number, $$cr?: ErrorTracker): Nullable<base_2> {
        return this.regexAccept(String.raw`(?:0b)`, $$dpth + 1, $$cr);
    }
    public matchbase_3($$dpth: number, $$cr?: ErrorTracker): Nullable<base_3> {
        return this.regexAccept(String.raw`(?:)`, $$dpth + 1, $$cr);
    }
    public matchbranchOp($$dpth: number, $$cr?: ErrorTracker): Nullable<branchOp> {
        return this.regexAccept(String.raw`(?:[_A-Za-z0-9]+)`, $$dpth + 1, $$cr);
    }
    public matchshiftType($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftType> {
        return this.choice<shiftType>([
            () => this.matchshiftType_1($$dpth + 1, $$cr),
            () => this.matchshiftType_2($$dpth + 1, $$cr),
            () => this.matchshiftType_3($$dpth + 1, $$cr),
            () => this.matchshiftType_4($$dpth + 1, $$cr),
            () => this.matchshiftType_5($$dpth + 1, $$cr),
            () => this.matchshiftType_6($$dpth + 1, $$cr),
        ]);
    }
    public matchshiftType_1($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftType_1> {
        return this.regexAccept(String.raw`(?:lsl)`, $$dpth + 1, $$cr);
    }
    public matchshiftType_2($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftType_2> {
        return this.regexAccept(String.raw`(?:asl)`, $$dpth + 1, $$cr);
    }
    public matchshiftType_3($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftType_3> {
        return this.regexAccept(String.raw`(?:lsr)`, $$dpth + 1, $$cr);
    }
    public matchshiftType_4($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftType_4> {
        return this.regexAccept(String.raw`(?:asr)`, $$dpth + 1, $$cr);
    }
    public matchshiftType_5($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftType_5> {
        return this.regexAccept(String.raw`(?:ror)`, $$dpth + 1, $$cr);
    }
    public matchshiftType_6($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftType_6> {
        return this.regexAccept(String.raw`(?:rrx)`, $$dpth + 1, $$cr);
    }
    public matchcondition($$dpth: number, $$cr?: ErrorTracker): Nullable<condition> {
        return this.run<condition>($$dpth,
            () => {
                let $scope$condType: Nullable<conditionType>;
                let $scope$updateStatusReg: Nullable<Nullable<string>>;
                let $$res: Nullable<condition> = null;
                if (true
                    && ($scope$condType = this.matchconditionType($$dpth + 1, $$cr)) !== null
                    && (($scope$updateStatusReg = this.regexAccept(String.raw`(?:s)`, $$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.condition, condType: $scope$condType, updateStatusReg: $scope$updateStatusReg};
                }
                return $$res;
            });
    }
    public matchconditionType($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType> {
        return this.choice<conditionType>([
            () => this.matchconditionType_1($$dpth + 1, $$cr),
            () => this.matchconditionType_2($$dpth + 1, $$cr),
            () => this.matchconditionType_3($$dpth + 1, $$cr),
            () => this.matchconditionType_4($$dpth + 1, $$cr),
            () => this.matchconditionType_5($$dpth + 1, $$cr),
            () => this.matchconditionType_6($$dpth + 1, $$cr),
            () => this.matchconditionType_7($$dpth + 1, $$cr),
            () => this.matchconditionType_8($$dpth + 1, $$cr),
            () => this.matchconditionType_9($$dpth + 1, $$cr),
            () => this.matchconditionType_10($$dpth + 1, $$cr),
            () => this.matchconditionType_11($$dpth + 1, $$cr),
            () => this.matchconditionType_12($$dpth + 1, $$cr),
            () => this.matchconditionType_13($$dpth + 1, $$cr),
            () => this.matchconditionType_14($$dpth + 1, $$cr),
            () => this.matchconditionType_15($$dpth + 1, $$cr),
            () => this.matchconditionType_16($$dpth + 1, $$cr),
            () => this.matchconditionType_17($$dpth + 1, $$cr),
            () => this.matchconditionType_18($$dpth + 1, $$cr),
            () => this.matchconditionType_19($$dpth + 1, $$cr),
        ]);
    }
    public matchconditionType_1($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_1> {
        return this.regexAccept(String.raw`(?:eq)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_2($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_2> {
        return this.regexAccept(String.raw`(?:ne)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_3($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_3> {
        return this.regexAccept(String.raw`(?:hs)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_4($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_4> {
        return this.regexAccept(String.raw`(?:cs)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_5($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_5> {
        return this.regexAccept(String.raw`(?:lo)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_6($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_6> {
        return this.regexAccept(String.raw`(?:cc)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_7($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_7> {
        return this.regexAccept(String.raw`(?:mi)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_8($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_8> {
        return this.regexAccept(String.raw`(?:pl)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_9($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_9> {
        return this.regexAccept(String.raw`(?:vs)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_10($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_10> {
        return this.regexAccept(String.raw`(?:vc)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_11($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_11> {
        return this.regexAccept(String.raw`(?:hi)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_12($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_12> {
        return this.regexAccept(String.raw`(?:ls)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_13($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_13> {
        return this.regexAccept(String.raw`(?:ge)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_14($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_14> {
        return this.regexAccept(String.raw`(?:lt)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_15($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_15> {
        return this.regexAccept(String.raw`(?:gt)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_16($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_16> {
        return this.regexAccept(String.raw`(?:le)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_17($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_17> {
        return this.regexAccept(String.raw`(?:al)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_18($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_18> {
        return this.regexAccept(String.raw`(?:nv)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_19($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_19> {
        return this.regexAccept(String.raw`(?:)`, $$dpth + 1, $$cr);
    }
    public matchws($$dpth: number, $$cr?: ErrorTracker): Nullable<ws> {
        return this.regexAccept(String.raw`(?:[ \t]+)`, $$dpth + 1, $$cr);
    }
    public matchwso($$dpth: number, $$cr?: ErrorTracker): Nullable<wso> {
        return this.regexAccept(String.raw`(?:[ \t]*)`, $$dpth + 1, $$cr);
    }
    public matchwson($$dpth: number, $$cr?: ErrorTracker): Nullable<wson> {
        return this.regexAccept(String.raw`(?:[ \t\n]*)`, $$dpth + 1, $$cr);
    }
    public matchnend($$dpth: number, $$cr?: ErrorTracker): Nullable<nend> {
        return this.choice<nend>([
            () => this.matchnend_1($$dpth + 1, $$cr),
            () => this.matchnend_2($$dpth + 1, $$cr),
        ]);
    }
    public matchnend_1($$dpth: number, $$cr?: ErrorTracker): Nullable<nend_1> {
        return this.regexAccept(String.raw`(?:\n)`, $$dpth + 1, $$cr);
    }
    public matchnend_2($$dpth: number, $$cr?: ErrorTracker): Nullable<nend_2> {
        return this.match$EOF($$cr);
    }
    public test(): boolean {
        const mrk = this.mark();
        const res = this.matchstart(0);
        const ans = res !== null;
        this.reset(mrk);
        return ans;
    }
    public parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchstart(0);
        if (res)
            return {ast: res, errs: []};
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.clearMemos();
        this.matchstart(0, rec);
        const err = rec.getErr()
        return {ast: res, errs: err !== null ? [err] : []}
    }
    public mark(): PosInfo {
        return this.pos;
    }
    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        for (;;) {
            const t = func();
            if (t === null) {
                break;
            }
            res.push(t);
        }
        if (star || res.length > 0) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn()
        if (res !== null)
            return res;
        this.reset(mrk);
        return null;
    }
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, dpth: number, cr?: ErrorTracker): Nullable<string> {
        return this.run<string>(dpth,
            () => {
                const reg = new RegExp(match, "y");
                const mrk = this.mark();
                reg.lastIndex = mrk.overallPos;
                const res = this.tryConsume(reg);
                if(cr) {
                    cr.record(mrk, res, {
                        kind: "RegexMatch",
                        // We substring from 3 to len - 1 to strip off the
                        // non-capture group syntax added as a WebKit workaround
                        literal: match.substring(3, match.length - 1),
                        negated: this.negating,
                    });
                }
                return res;
            });
    }
    private tryConsume(reg: RegExp): Nullable<string> {
        const res = reg.exec(this.input);
        if (res) {
            let lineJmp = 0;
            let lind = -1;
            for (let i = 0; i < res[0].length; ++i) {
                if (res[0][i] === "\n") {
                    ++lineJmp;
                    lind = i;
                }
            }
            this.pos = {
                overallPos: reg.lastIndex,
                line: this.pos.line + lineJmp,
                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)
            };
            return res[0];
        }
        return null;
    }
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {
        const $scope$pos = this.mark();
        const $scope$memoRes = memo.get($scope$pos.overallPos);
        if(this.memoSafe && $scope$memoRes !== undefined) {
        this.reset($scope$memoRes[1]);
        return $scope$memoRes[0];
        }
        const $scope$result = rule();
        if(this.memoSafe)
        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);
        return $scope$result;
    }
    private match$EOF(et?: ErrorTracker): Nullable<{kind: ASTKinds.$EOF}> {
        const res: {kind: ASTKinds.$EOF} | null = this.finished() ? { kind: ASTKinds.$EOF } : null;
        if(et)
            et.record(this.mark(), res, { kind: "EOF", negated: this.negating });
        return res;
    }
}
export function parse(s: string): ParseResult {
    const p = new Parser(s);
    return p.parse();
}
export interface ParseResult {
    ast: Nullable<start>;
    errs: SyntaxErr[];
}
export interface PosInfo {
    readonly overallPos: number;
    readonly line: number;
    readonly offset: number;
}
export interface RegexMatch {
    readonly kind: "RegexMatch";
    readonly negated: boolean;
    readonly literal: string;
}
export type EOFMatch = { kind: "EOF"; negated: boolean };
export type MatchAttempt = RegexMatch | EOFMatch;
export class SyntaxErr {
    public pos: PosInfo;
    public expmatches: MatchAttempt[];
    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {
        this.pos = pos;
        this.expmatches = [...expmatches];
    }
    public toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === "EOF" ? " EOF" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;
    }
}
class ErrorTracker {
    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};
    private regexset: Set<string> = new Set();
    private pmatches: MatchAttempt[] = [];
    public record(pos: PosInfo, result: any, att: MatchAttempt) {
        if ((result === null) === att.negated)
            return;
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.pmatches = [];
            this.regexset.clear()
        }
        if (this.mxpos.overallPos === pos.overallPos) {
            if(att.kind === "RegexMatch") {
                if(!this.regexset.has(att.literal))
                    this.pmatches.push(att);
                this.regexset.add(att.literal);
            } else {
                this.pmatches.push(att);
            }
        }
    }
    public getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1)
            return new SyntaxErr(this.mxpos, this.pmatches);
        return null;
    }
}