/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* start := start=line
* line := '[\s]*' label=label? '[\s]*' currentLine=directive wso comment=comment? nend nextLine=line |
*         '[\s]*' label=label? '[\s]*' currentLine=instruction wso comment=comment? nend nextLine=line |
*         '[\s]*' label=label? '[\s]*' currentLine=commentLine nend nextLine=line |
*         '[\s]*' $
* //directive := directive='.arm' | directive='.text' | directive='.data' | directive='.align' | directive='.global' ws '_start'
* directive := directive=ascii
* ascii := '.ascii' ws '"' data='[ -!#-~]*' '"'
* label := label='[_A-Za-z0-9]+' ':'
* instruction := instruction=art | instruction=log | instruction=copyJump | instruction=loadStore | instruction=softwareInterrupt
* commentLine := commentLine=comment
* emptyLine := emptyLine=wso
* comment := comment='//[ \t\S]*' | comment='\/\*[ \t\S]*\*\/'
* //------------------------------------------------------------------------------------------------
* art := inst=artInst cond=condition ws operands=artOp | inst='mul' cond=condition ws operands=artMulOp | inst='mla' cond=condition ws operands=artMlaOp
* artInst := 'add' | 'adc' | 'sub' | 'sbc' | 'rsb' | 'rsc'
* artOp := artOp3 | artOp2
* artOp2 := op1=regOp wso ',' wso op2=op
* artOp3 := op1=regOp wso ',' wso op2=regOp wso ',' wso op3=op
* artMulOp := op1=regOp wso ',' wso op2=regOp wso ',' wso op3=regOp
* artMlaOp := op1=regOp wso ',' wso op2=regOp wso ',' wso op3=regOp wso ',' wso op4=regOp
* //------------------------------------------------------------------------------------------------
* log := inst=logInst cond=condition ws operands=logOp | inst=logCmpInst cond=condition ws operands=logOp2
* logInst := 'and' | 'orr' | 'eor' | 'bic'
* logCmpInst := 'cmp' | 'cmn' | 'tst' | 'teq'
* logOp := logOp3 | logOp2
* logOp2 := op1=regOp wso ',' wso op2=op
* logOp3 := op1=regOp wso ',' wso op2=regOp wso ',' wso op3=op
* //------------------------------------------------------------------------------------------------
* copyJump := inst=copyInst cond=condition ws operands=copyOp | inst=jumpInst1 cond=condition ws operands=jumpOp | inst=jumpInst2 cond=condition ws operands=jumpOp
* copyInst := 'mov' | 'mvn'
* jumpInst1 := 'b'
* jumpInst2 := 'bl'
* copyOp := op1=regOp wso ',' wso op2=op
* jumpOp := op1=branchOp
* //------------------------------------------------------------------------------------------------
* loadStore := inst=loadStoreInst cond=condition ws operands=loadStoreOp | inst=loadStoreInst cond=condition ws operands=loadImmediateOp | inst=loadStoreInst cond=condition ws operands=loadImmediateBranchOp
* loadStoreInst := 'ldr' | 'str'
* loadStoreOp := op1=regOp wso ',' wso op2=addressingMode
* loadImmediateOp := op1=regOp wso ',' wso op2=immOp
* loadImmediateBranchOp := op1=regOp wso ',' wso '=' op2=branchOp
* //------------------------------------------------------------------------------------------------
* softwareInterrupt := inst='swi' cond=condition ws operands='#0'
* //------------------------------------------------------------------------------------------------
* op := shiftOp=shiftOp | regImmOp=regImmOp
* regImmOp := regOp=regOp | immOp=immOp
* shiftOp := opToShift=regImmOp wso ',' wso shiftType=shiftType wso opShift=regImmOp
* addressingMode := '\[' wso reg=regOp wso '\]' offset=offset? | '\[' wso reg=regOp offset=offset? wso '\]' increment='!'?
* offset := wso ',' wso sign=sign offset=op
* regOp := regOp='r[0-9]+' | 'pc' | 'lr'
* immOp := immType=immType sign=sign base=base number='[0-9a-f]+'
* immType := '#' | '='
* base := '0x' | '0b' | '0o' | ''
* sign := '-' | '\+' | ''
* branchOp := '[_A-Za-z0-9]+'
* shiftType := 'lsl' | 'asl' | 'lsr' | 'asr' | 'ror' | 'rrx'
* condition := condType=conditionType updateStatusReg='s'?
* conditionType := 'eq' | 'ne' | 'hs' | 'cs' | 'lo' | 'cc' | 'mi' | 'pl' | 'vs' | 'vc' | 'hi' | 'ls' | 'ge' | 'lt' | 'gt' | 'le' | 'al' | 'nv' | ''
* //------------------------------------------------------------------------------------------------
* ws := '[ \t]+'
* wso := '[ \t]*'
* nend := '\n' | $
*/
type Nullable<T> = T | null;
type $$RuleType<T> = () => Nullable<T>;
interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    start = "start",
    line_1 = "line_1",
    line_2 = "line_2",
    line_3 = "line_3",
    line_4 = "line_4",
    directive = "directive",
    ascii = "ascii",
    label = "label",
    instruction_1 = "instruction_1",
    instruction_2 = "instruction_2",
    instruction_3 = "instruction_3",
    instruction_4 = "instruction_4",
    instruction_5 = "instruction_5",
    commentLine = "commentLine",
    emptyLine = "emptyLine",
    comment_1 = "comment_1",
    comment_2 = "comment_2",
    art_1 = "art_1",
    art_2 = "art_2",
    art_3 = "art_3",
    artInst_1 = "artInst_1",
    artInst_2 = "artInst_2",
    artInst_3 = "artInst_3",
    artInst_4 = "artInst_4",
    artInst_5 = "artInst_5",
    artInst_6 = "artInst_6",
    artOp_1 = "artOp_1",
    artOp_2 = "artOp_2",
    artOp2 = "artOp2",
    artOp3 = "artOp3",
    artMulOp = "artMulOp",
    artMlaOp = "artMlaOp",
    log_1 = "log_1",
    log_2 = "log_2",
    logInst_1 = "logInst_1",
    logInst_2 = "logInst_2",
    logInst_3 = "logInst_3",
    logInst_4 = "logInst_4",
    logCmpInst_1 = "logCmpInst_1",
    logCmpInst_2 = "logCmpInst_2",
    logCmpInst_3 = "logCmpInst_3",
    logCmpInst_4 = "logCmpInst_4",
    logOp_1 = "logOp_1",
    logOp_2 = "logOp_2",
    logOp2 = "logOp2",
    logOp3 = "logOp3",
    copyJump_1 = "copyJump_1",
    copyJump_2 = "copyJump_2",
    copyJump_3 = "copyJump_3",
    copyInst_1 = "copyInst_1",
    copyInst_2 = "copyInst_2",
    jumpInst1 = "jumpInst1",
    jumpInst2 = "jumpInst2",
    copyOp = "copyOp",
    jumpOp = "jumpOp",
    loadStore_1 = "loadStore_1",
    loadStore_2 = "loadStore_2",
    loadStore_3 = "loadStore_3",
    loadStoreInst_1 = "loadStoreInst_1",
    loadStoreInst_2 = "loadStoreInst_2",
    loadStoreOp = "loadStoreOp",
    loadImmediateOp = "loadImmediateOp",
    loadImmediateBranchOp = "loadImmediateBranchOp",
    softwareInterrupt = "softwareInterrupt",
    op_1 = "op_1",
    op_2 = "op_2",
    regImmOp_1 = "regImmOp_1",
    regImmOp_2 = "regImmOp_2",
    shiftOp = "shiftOp",
    addressingMode_1 = "addressingMode_1",
    addressingMode_2 = "addressingMode_2",
    offset = "offset",
    regOp_1 = "regOp_1",
    regOp_2 = "regOp_2",
    regOp_3 = "regOp_3",
    immOp = "immOp",
    immType_1 = "immType_1",
    immType_2 = "immType_2",
    base_1 = "base_1",
    base_2 = "base_2",
    base_3 = "base_3",
    base_4 = "base_4",
    sign_1 = "sign_1",
    sign_2 = "sign_2",
    sign_3 = "sign_3",
    branchOp = "branchOp",
    shiftType_1 = "shiftType_1",
    shiftType_2 = "shiftType_2",
    shiftType_3 = "shiftType_3",
    shiftType_4 = "shiftType_4",
    shiftType_5 = "shiftType_5",
    shiftType_6 = "shiftType_6",
    condition = "condition",
    conditionType_1 = "conditionType_1",
    conditionType_2 = "conditionType_2",
    conditionType_3 = "conditionType_3",
    conditionType_4 = "conditionType_4",
    conditionType_5 = "conditionType_5",
    conditionType_6 = "conditionType_6",
    conditionType_7 = "conditionType_7",
    conditionType_8 = "conditionType_8",
    conditionType_9 = "conditionType_9",
    conditionType_10 = "conditionType_10",
    conditionType_11 = "conditionType_11",
    conditionType_12 = "conditionType_12",
    conditionType_13 = "conditionType_13",
    conditionType_14 = "conditionType_14",
    conditionType_15 = "conditionType_15",
    conditionType_16 = "conditionType_16",
    conditionType_17 = "conditionType_17",
    conditionType_18 = "conditionType_18",
    conditionType_19 = "conditionType_19",
    ws = "ws",
    wso = "wso",
    nend_1 = "nend_1",
    nend_2 = "nend_2",
    $EOF = "$EOF",
}
export interface start {
    kind: ASTKinds.start;
    start: line;
}
export type line = line_1 | line_2 | line_3 | line_4;
export interface line_1 {
    kind: ASTKinds.line_1;
    label: Nullable<label>;
    currentLine: directive;
    comment: Nullable<comment>;
    nextLine: line;
}
export interface line_2 {
    kind: ASTKinds.line_2;
    label: Nullable<label>;
    currentLine: instruction;
    comment: Nullable<comment>;
    nextLine: line;
}
export interface line_3 {
    kind: ASTKinds.line_3;
    label: Nullable<label>;
    currentLine: commentLine;
    nextLine: line;
}
export interface line_4 {
    kind: ASTKinds.line_4;
}
export interface directive {
    kind: ASTKinds.directive;
    directive: ascii;
}
export interface ascii {
    kind: ASTKinds.ascii;
    data: string;
}
export interface label {
    kind: ASTKinds.label;
    label: string;
}
export type instruction = instruction_1 | instruction_2 | instruction_3 | instruction_4 | instruction_5;
export interface instruction_1 {
    kind: ASTKinds.instruction_1;
    instruction: art;
}
export interface instruction_2 {
    kind: ASTKinds.instruction_2;
    instruction: log;
}
export interface instruction_3 {
    kind: ASTKinds.instruction_3;
    instruction: copyJump;
}
export interface instruction_4 {
    kind: ASTKinds.instruction_4;
    instruction: loadStore;
}
export interface instruction_5 {
    kind: ASTKinds.instruction_5;
    instruction: softwareInterrupt;
}
export interface commentLine {
    kind: ASTKinds.commentLine;
    commentLine: comment;
}
export interface emptyLine {
    kind: ASTKinds.emptyLine;
    emptyLine: wso;
}
export type comment = comment_1 | comment_2;
export interface comment_1 {
    kind: ASTKinds.comment_1;
    comment: string;
}
export interface comment_2 {
    kind: ASTKinds.comment_2;
    comment: string;
}
export type art = art_1 | art_2 | art_3;
export interface art_1 {
    kind: ASTKinds.art_1;
    inst: artInst;
    cond: condition;
    operands: artOp;
}
export interface art_2 {
    kind: ASTKinds.art_2;
    inst: string;
    cond: condition;
    operands: artMulOp;
}
export interface art_3 {
    kind: ASTKinds.art_3;
    inst: string;
    cond: condition;
    operands: artMlaOp;
}
export type artInst = artInst_1 | artInst_2 | artInst_3 | artInst_4 | artInst_5 | artInst_6;
export type artInst_1 = string;
export type artInst_2 = string;
export type artInst_3 = string;
export type artInst_4 = string;
export type artInst_5 = string;
export type artInst_6 = string;
export type artOp = artOp_1 | artOp_2;
export type artOp_1 = artOp3;
export type artOp_2 = artOp2;
export interface artOp2 {
    kind: ASTKinds.artOp2;
    op1: regOp;
    op2: op;
}
export interface artOp3 {
    kind: ASTKinds.artOp3;
    op1: regOp;
    op2: regOp;
    op3: op;
}
export interface artMulOp {
    kind: ASTKinds.artMulOp;
    op1: regOp;
    op2: regOp;
    op3: regOp;
}
export interface artMlaOp {
    kind: ASTKinds.artMlaOp;
    op1: regOp;
    op2: regOp;
    op3: regOp;
    op4: regOp;
}
export type log = log_1 | log_2;
export interface log_1 {
    kind: ASTKinds.log_1;
    inst: logInst;
    cond: condition;
    operands: logOp;
}
export interface log_2 {
    kind: ASTKinds.log_2;
    inst: logCmpInst;
    cond: condition;
    operands: logOp2;
}
export type logInst = logInst_1 | logInst_2 | logInst_3 | logInst_4;
export type logInst_1 = string;
export type logInst_2 = string;
export type logInst_3 = string;
export type logInst_4 = string;
export type logCmpInst = logCmpInst_1 | logCmpInst_2 | logCmpInst_3 | logCmpInst_4;
export type logCmpInst_1 = string;
export type logCmpInst_2 = string;
export type logCmpInst_3 = string;
export type logCmpInst_4 = string;
export type logOp = logOp_1 | logOp_2;
export type logOp_1 = logOp3;
export type logOp_2 = logOp2;
export interface logOp2 {
    kind: ASTKinds.logOp2;
    op1: regOp;
    op2: op;
}
export interface logOp3 {
    kind: ASTKinds.logOp3;
    op1: regOp;
    op2: regOp;
    op3: op;
}
export type copyJump = copyJump_1 | copyJump_2 | copyJump_3;
export interface copyJump_1 {
    kind: ASTKinds.copyJump_1;
    inst: copyInst;
    cond: condition;
    operands: copyOp;
}
export interface copyJump_2 {
    kind: ASTKinds.copyJump_2;
    inst: jumpInst1;
    cond: condition;
    operands: jumpOp;
}
export interface copyJump_3 {
    kind: ASTKinds.copyJump_3;
    inst: jumpInst2;
    cond: condition;
    operands: jumpOp;
}
export type copyInst = copyInst_1 | copyInst_2;
export type copyInst_1 = string;
export type copyInst_2 = string;
export type jumpInst1 = string;
export type jumpInst2 = string;
export interface copyOp {
    kind: ASTKinds.copyOp;
    op1: regOp;
    op2: op;
}
export interface jumpOp {
    kind: ASTKinds.jumpOp;
    op1: branchOp;
}
export type loadStore = loadStore_1 | loadStore_2 | loadStore_3;
export interface loadStore_1 {
    kind: ASTKinds.loadStore_1;
    inst: loadStoreInst;
    cond: condition;
    operands: loadStoreOp;
}
export interface loadStore_2 {
    kind: ASTKinds.loadStore_2;
    inst: loadStoreInst;
    cond: condition;
    operands: loadImmediateOp;
}
export interface loadStore_3 {
    kind: ASTKinds.loadStore_3;
    inst: loadStoreInst;
    cond: condition;
    operands: loadImmediateBranchOp;
}
export type loadStoreInst = loadStoreInst_1 | loadStoreInst_2;
export type loadStoreInst_1 = string;
export type loadStoreInst_2 = string;
export interface loadStoreOp {
    kind: ASTKinds.loadStoreOp;
    op1: regOp;
    op2: addressingMode;
}
export interface loadImmediateOp {
    kind: ASTKinds.loadImmediateOp;
    op1: regOp;
    op2: immOp;
}
export interface loadImmediateBranchOp {
    kind: ASTKinds.loadImmediateBranchOp;
    op1: regOp;
    op2: branchOp;
}
export interface softwareInterrupt {
    kind: ASTKinds.softwareInterrupt;
    inst: string;
    cond: condition;
    operands: string;
}
export type op = op_1 | op_2;
export interface op_1 {
    kind: ASTKinds.op_1;
    shiftOp: shiftOp;
}
export interface op_2 {
    kind: ASTKinds.op_2;
    regImmOp: regImmOp;
}
export type regImmOp = regImmOp_1 | regImmOp_2;
export interface regImmOp_1 {
    kind: ASTKinds.regImmOp_1;
    regOp: regOp;
}
export interface regImmOp_2 {
    kind: ASTKinds.regImmOp_2;
    immOp: immOp;
}
export interface shiftOp {
    kind: ASTKinds.shiftOp;
    opToShift: regImmOp;
    shiftType: shiftType;
    opShift: regImmOp;
}
export type addressingMode = addressingMode_1 | addressingMode_2;
export interface addressingMode_1 {
    kind: ASTKinds.addressingMode_1;
    reg: regOp;
    offset: Nullable<offset>;
}
export interface addressingMode_2 {
    kind: ASTKinds.addressingMode_2;
    reg: regOp;
    offset: Nullable<offset>;
    increment: Nullable<string>;
}
export interface offset {
    kind: ASTKinds.offset;
    sign: sign;
    offset: op;
}
export type regOp = regOp_1 | regOp_2 | regOp_3;
export interface regOp_1 {
    kind: ASTKinds.regOp_1;
    regOp: string;
}
export type regOp_2 = string;
export type regOp_3 = string;
export interface immOp {
    kind: ASTKinds.immOp;
    immType: immType;
    sign: sign;
    base: base;
    number: string;
}
export type immType = immType_1 | immType_2;
export type immType_1 = string;
export type immType_2 = string;
export type base = base_1 | base_2 | base_3 | base_4;
export type base_1 = string;
export type base_2 = string;
export type base_3 = string;
export type base_4 = string;
export type sign = sign_1 | sign_2 | sign_3;
export type sign_1 = string;
export type sign_2 = string;
export type sign_3 = string;
export type branchOp = string;
export type shiftType = shiftType_1 | shiftType_2 | shiftType_3 | shiftType_4 | shiftType_5 | shiftType_6;
export type shiftType_1 = string;
export type shiftType_2 = string;
export type shiftType_3 = string;
export type shiftType_4 = string;
export type shiftType_5 = string;
export type shiftType_6 = string;
export interface condition {
    kind: ASTKinds.condition;
    condType: conditionType;
    updateStatusReg: Nullable<string>;
}
export type conditionType = conditionType_1 | conditionType_2 | conditionType_3 | conditionType_4 | conditionType_5 | conditionType_6 | conditionType_7 | conditionType_8 | conditionType_9 | conditionType_10 | conditionType_11 | conditionType_12 | conditionType_13 | conditionType_14 | conditionType_15 | conditionType_16 | conditionType_17 | conditionType_18 | conditionType_19;
export type conditionType_1 = string;
export type conditionType_2 = string;
export type conditionType_3 = string;
export type conditionType_4 = string;
export type conditionType_5 = string;
export type conditionType_6 = string;
export type conditionType_7 = string;
export type conditionType_8 = string;
export type conditionType_9 = string;
export type conditionType_10 = string;
export type conditionType_11 = string;
export type conditionType_12 = string;
export type conditionType_13 = string;
export type conditionType_14 = string;
export type conditionType_15 = string;
export type conditionType_16 = string;
export type conditionType_17 = string;
export type conditionType_18 = string;
export type conditionType_19 = string;
export type ws = string;
export type wso = string;
export type nend = nend_1 | nend_2;
export type nend_1 = string;
export type nend_2 = {kind: ASTKinds.$EOF};
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating: boolean = false;
    private memoSafe: boolean = true;
    constructor(input: string) {
        this.pos = {overallPos: 0, line: 1, offset: 0};
        this.input = input;
    }
    public reset(pos: PosInfo) {
        this.pos = pos;
    }
    public finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    public clearMemos(): void {
    }
    public matchstart($$dpth: number, $$cr?: ErrorTracker): Nullable<start> {
        return this.run<start>($$dpth,
            () => {
                let $scope$start: Nullable<line>;
                let $$res: Nullable<start> = null;
                if (true
                    && ($scope$start = this.matchline($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.start, start: $scope$start};
                }
                return $$res;
            });
    }
    public matchline($$dpth: number, $$cr?: ErrorTracker): Nullable<line> {
        return this.choice<line>([
            () => this.matchline_1($$dpth + 1, $$cr),
            () => this.matchline_2($$dpth + 1, $$cr),
            () => this.matchline_3($$dpth + 1, $$cr),
            () => this.matchline_4($$dpth + 1, $$cr),
        ]);
    }
    public matchline_1($$dpth: number, $$cr?: ErrorTracker): Nullable<line_1> {
        return this.run<line_1>($$dpth,
            () => {
                let $scope$label: Nullable<Nullable<label>>;
                let $scope$currentLine: Nullable<directive>;
                let $scope$comment: Nullable<Nullable<comment>>;
                let $scope$nextLine: Nullable<line>;
                let $$res: Nullable<line_1> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[\s]*)`, $$dpth + 1, $$cr) !== null
                    && (($scope$label = this.matchlabel($$dpth + 1, $$cr)) || true)
                    && this.regexAccept(String.raw`(?:[\s]*)`, $$dpth + 1, $$cr) !== null
                    && ($scope$currentLine = this.matchdirective($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && (($scope$comment = this.matchcomment($$dpth + 1, $$cr)) || true)
                    && this.matchnend($$dpth + 1, $$cr) !== null
                    && ($scope$nextLine = this.matchline($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.line_1, label: $scope$label, currentLine: $scope$currentLine, comment: $scope$comment, nextLine: $scope$nextLine};
                }
                return $$res;
            });
    }
    public matchline_2($$dpth: number, $$cr?: ErrorTracker): Nullable<line_2> {
        return this.run<line_2>($$dpth,
            () => {
                let $scope$label: Nullable<Nullable<label>>;
                let $scope$currentLine: Nullable<instruction>;
                let $scope$comment: Nullable<Nullable<comment>>;
                let $scope$nextLine: Nullable<line>;
                let $$res: Nullable<line_2> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[\s]*)`, $$dpth + 1, $$cr) !== null
                    && (($scope$label = this.matchlabel($$dpth + 1, $$cr)) || true)
                    && this.regexAccept(String.raw`(?:[\s]*)`, $$dpth + 1, $$cr) !== null
                    && ($scope$currentLine = this.matchinstruction($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && (($scope$comment = this.matchcomment($$dpth + 1, $$cr)) || true)
                    && this.matchnend($$dpth + 1, $$cr) !== null
                    && ($scope$nextLine = this.matchline($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.line_2, label: $scope$label, currentLine: $scope$currentLine, comment: $scope$comment, nextLine: $scope$nextLine};
                }
                return $$res;
            });
    }
    public matchline_3($$dpth: number, $$cr?: ErrorTracker): Nullable<line_3> {
        return this.run<line_3>($$dpth,
            () => {
                let $scope$label: Nullable<Nullable<label>>;
                let $scope$currentLine: Nullable<commentLine>;
                let $scope$nextLine: Nullable<line>;
                let $$res: Nullable<line_3> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[\s]*)`, $$dpth + 1, $$cr) !== null
                    && (($scope$label = this.matchlabel($$dpth + 1, $$cr)) || true)
                    && this.regexAccept(String.raw`(?:[\s]*)`, $$dpth + 1, $$cr) !== null
                    && ($scope$currentLine = this.matchcommentLine($$dpth + 1, $$cr)) !== null
                    && this.matchnend($$dpth + 1, $$cr) !== null
                    && ($scope$nextLine = this.matchline($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.line_3, label: $scope$label, currentLine: $scope$currentLine, nextLine: $scope$nextLine};
                }
                return $$res;
            });
    }
    public matchline_4($$dpth: number, $$cr?: ErrorTracker): Nullable<line_4> {
        return this.run<line_4>($$dpth,
            () => {
                let $$res: Nullable<line_4> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[\s]*)`, $$dpth + 1, $$cr) !== null
                    && this.match$EOF($$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.line_4, };
                }
                return $$res;
            });
    }
    public matchdirective($$dpth: number, $$cr?: ErrorTracker): Nullable<directive> {
        return this.run<directive>($$dpth,
            () => {
                let $scope$directive: Nullable<ascii>;
                let $$res: Nullable<directive> = null;
                if (true
                    && ($scope$directive = this.matchascii($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.directive, directive: $scope$directive};
                }
                return $$res;
            });
    }
    public matchascii($$dpth: number, $$cr?: ErrorTracker): Nullable<ascii> {
        return this.run<ascii>($$dpth,
            () => {
                let $scope$data: Nullable<string>;
                let $$res: Nullable<ascii> = null;
                if (true
                    && this.regexAccept(String.raw`(?:.ascii)`, $$dpth + 1, $$cr) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:")`, $$dpth + 1, $$cr) !== null
                    && ($scope$data = this.regexAccept(String.raw`(?:[ -!#-~]*)`, $$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:")`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.ascii, data: $scope$data};
                }
                return $$res;
            });
    }
    public matchlabel($$dpth: number, $$cr?: ErrorTracker): Nullable<label> {
        return this.run<label>($$dpth,
            () => {
                let $scope$label: Nullable<string>;
                let $$res: Nullable<label> = null;
                if (true
                    && ($scope$label = this.regexAccept(String.raw`(?:[_A-Za-z0-9]+)`, $$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?::)`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.label, label: $scope$label};
                }
                return $$res;
            });
    }
    public matchinstruction($$dpth: number, $$cr?: ErrorTracker): Nullable<instruction> {
        return this.choice<instruction>([
            () => this.matchinstruction_1($$dpth + 1, $$cr),
            () => this.matchinstruction_2($$dpth + 1, $$cr),
            () => this.matchinstruction_3($$dpth + 1, $$cr),
            () => this.matchinstruction_4($$dpth + 1, $$cr),
            () => this.matchinstruction_5($$dpth + 1, $$cr),
        ]);
    }
    public matchinstruction_1($$dpth: number, $$cr?: ErrorTracker): Nullable<instruction_1> {
        return this.run<instruction_1>($$dpth,
            () => {
                let $scope$instruction: Nullable<art>;
                let $$res: Nullable<instruction_1> = null;
                if (true
                    && ($scope$instruction = this.matchart($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.instruction_1, instruction: $scope$instruction};
                }
                return $$res;
            });
    }
    public matchinstruction_2($$dpth: number, $$cr?: ErrorTracker): Nullable<instruction_2> {
        return this.run<instruction_2>($$dpth,
            () => {
                let $scope$instruction: Nullable<log>;
                let $$res: Nullable<instruction_2> = null;
                if (true
                    && ($scope$instruction = this.matchlog($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.instruction_2, instruction: $scope$instruction};
                }
                return $$res;
            });
    }
    public matchinstruction_3($$dpth: number, $$cr?: ErrorTracker): Nullable<instruction_3> {
        return this.run<instruction_3>($$dpth,
            () => {
                let $scope$instruction: Nullable<copyJump>;
                let $$res: Nullable<instruction_3> = null;
                if (true
                    && ($scope$instruction = this.matchcopyJump($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.instruction_3, instruction: $scope$instruction};
                }
                return $$res;
            });
    }
    public matchinstruction_4($$dpth: number, $$cr?: ErrorTracker): Nullable<instruction_4> {
        return this.run<instruction_4>($$dpth,
            () => {
                let $scope$instruction: Nullable<loadStore>;
                let $$res: Nullable<instruction_4> = null;
                if (true
                    && ($scope$instruction = this.matchloadStore($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.instruction_4, instruction: $scope$instruction};
                }
                return $$res;
            });
    }
    public matchinstruction_5($$dpth: number, $$cr?: ErrorTracker): Nullable<instruction_5> {
        return this.run<instruction_5>($$dpth,
            () => {
                let $scope$instruction: Nullable<softwareInterrupt>;
                let $$res: Nullable<instruction_5> = null;
                if (true
                    && ($scope$instruction = this.matchsoftwareInterrupt($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.instruction_5, instruction: $scope$instruction};
                }
                return $$res;
            });
    }
    public matchcommentLine($$dpth: number, $$cr?: ErrorTracker): Nullable<commentLine> {
        return this.run<commentLine>($$dpth,
            () => {
                let $scope$commentLine: Nullable<comment>;
                let $$res: Nullable<commentLine> = null;
                if (true
                    && ($scope$commentLine = this.matchcomment($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.commentLine, commentLine: $scope$commentLine};
                }
                return $$res;
            });
    }
    public matchemptyLine($$dpth: number, $$cr?: ErrorTracker): Nullable<emptyLine> {
        return this.run<emptyLine>($$dpth,
            () => {
                let $scope$emptyLine: Nullable<wso>;
                let $$res: Nullable<emptyLine> = null;
                if (true
                    && ($scope$emptyLine = this.matchwso($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.emptyLine, emptyLine: $scope$emptyLine};
                }
                return $$res;
            });
    }
    public matchcomment($$dpth: number, $$cr?: ErrorTracker): Nullable<comment> {
        return this.choice<comment>([
            () => this.matchcomment_1($$dpth + 1, $$cr),
            () => this.matchcomment_2($$dpth + 1, $$cr),
        ]);
    }
    public matchcomment_1($$dpth: number, $$cr?: ErrorTracker): Nullable<comment_1> {
        return this.run<comment_1>($$dpth,
            () => {
                let $scope$comment: Nullable<string>;
                let $$res: Nullable<comment_1> = null;
                if (true
                    && ($scope$comment = this.regexAccept(String.raw`(?://[ \t\S]*)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.comment_1, comment: $scope$comment};
                }
                return $$res;
            });
    }
    public matchcomment_2($$dpth: number, $$cr?: ErrorTracker): Nullable<comment_2> {
        return this.run<comment_2>($$dpth,
            () => {
                let $scope$comment: Nullable<string>;
                let $$res: Nullable<comment_2> = null;
                if (true
                    && ($scope$comment = this.regexAccept(String.raw`(?:\/\*[ \t\S]*\*\/)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.comment_2, comment: $scope$comment};
                }
                return $$res;
            });
    }
    public matchart($$dpth: number, $$cr?: ErrorTracker): Nullable<art> {
        return this.choice<art>([
            () => this.matchart_1($$dpth + 1, $$cr),
            () => this.matchart_2($$dpth + 1, $$cr),
            () => this.matchart_3($$dpth + 1, $$cr),
        ]);
    }
    public matchart_1($$dpth: number, $$cr?: ErrorTracker): Nullable<art_1> {
        return this.run<art_1>($$dpth,
            () => {
                let $scope$inst: Nullable<artInst>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<artOp>;
                let $$res: Nullable<art_1> = null;
                if (true
                    && ($scope$inst = this.matchartInst($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchartOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.art_1, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchart_2($$dpth: number, $$cr?: ErrorTracker): Nullable<art_2> {
        return this.run<art_2>($$dpth,
            () => {
                let $scope$inst: Nullable<string>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<artMulOp>;
                let $$res: Nullable<art_2> = null;
                if (true
                    && ($scope$inst = this.regexAccept(String.raw`(?:mul)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchartMulOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.art_2, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchart_3($$dpth: number, $$cr?: ErrorTracker): Nullable<art_3> {
        return this.run<art_3>($$dpth,
            () => {
                let $scope$inst: Nullable<string>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<artMlaOp>;
                let $$res: Nullable<art_3> = null;
                if (true
                    && ($scope$inst = this.regexAccept(String.raw`(?:mla)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchartMlaOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.art_3, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchartInst($$dpth: number, $$cr?: ErrorTracker): Nullable<artInst> {
        return this.choice<artInst>([
            () => this.matchartInst_1($$dpth + 1, $$cr),
            () => this.matchartInst_2($$dpth + 1, $$cr),
            () => this.matchartInst_3($$dpth + 1, $$cr),
            () => this.matchartInst_4($$dpth + 1, $$cr),
            () => this.matchartInst_5($$dpth + 1, $$cr),
            () => this.matchartInst_6($$dpth + 1, $$cr),
        ]);
    }
    public matchartInst_1($$dpth: number, $$cr?: ErrorTracker): Nullable<artInst_1> {
        return this.regexAccept(String.raw`(?:add)`, $$dpth + 1, $$cr);
    }
    public matchartInst_2($$dpth: number, $$cr?: ErrorTracker): Nullable<artInst_2> {
        return this.regexAccept(String.raw`(?:adc)`, $$dpth + 1, $$cr);
    }
    public matchartInst_3($$dpth: number, $$cr?: ErrorTracker): Nullable<artInst_3> {
        return this.regexAccept(String.raw`(?:sub)`, $$dpth + 1, $$cr);
    }
    public matchartInst_4($$dpth: number, $$cr?: ErrorTracker): Nullable<artInst_4> {
        return this.regexAccept(String.raw`(?:sbc)`, $$dpth + 1, $$cr);
    }
    public matchartInst_5($$dpth: number, $$cr?: ErrorTracker): Nullable<artInst_5> {
        return this.regexAccept(String.raw`(?:rsb)`, $$dpth + 1, $$cr);
    }
    public matchartInst_6($$dpth: number, $$cr?: ErrorTracker): Nullable<artInst_6> {
        return this.regexAccept(String.raw`(?:rsc)`, $$dpth + 1, $$cr);
    }
    public matchartOp($$dpth: number, $$cr?: ErrorTracker): Nullable<artOp> {
        return this.choice<artOp>([
            () => this.matchartOp_1($$dpth + 1, $$cr),
            () => this.matchartOp_2($$dpth + 1, $$cr),
        ]);
    }
    public matchartOp_1($$dpth: number, $$cr?: ErrorTracker): Nullable<artOp_1> {
        return this.matchartOp3($$dpth + 1, $$cr);
    }
    public matchartOp_2($$dpth: number, $$cr?: ErrorTracker): Nullable<artOp_2> {
        return this.matchartOp2($$dpth + 1, $$cr);
    }
    public matchartOp2($$dpth: number, $$cr?: ErrorTracker): Nullable<artOp2> {
        return this.run<artOp2>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<op>;
                let $$res: Nullable<artOp2> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchop($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.artOp2, op1: $scope$op1, op2: $scope$op2};
                }
                return $$res;
            });
    }
    public matchartOp3($$dpth: number, $$cr?: ErrorTracker): Nullable<artOp3> {
        return this.run<artOp3>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<regOp>;
                let $scope$op3: Nullable<op>;
                let $$res: Nullable<artOp3> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op3 = this.matchop($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.artOp3, op1: $scope$op1, op2: $scope$op2, op3: $scope$op3};
                }
                return $$res;
            });
    }
    public matchartMulOp($$dpth: number, $$cr?: ErrorTracker): Nullable<artMulOp> {
        return this.run<artMulOp>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<regOp>;
                let $scope$op3: Nullable<regOp>;
                let $$res: Nullable<artMulOp> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op3 = this.matchregOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.artMulOp, op1: $scope$op1, op2: $scope$op2, op3: $scope$op3};
                }
                return $$res;
            });
    }
    public matchartMlaOp($$dpth: number, $$cr?: ErrorTracker): Nullable<artMlaOp> {
        return this.run<artMlaOp>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<regOp>;
                let $scope$op3: Nullable<regOp>;
                let $scope$op4: Nullable<regOp>;
                let $$res: Nullable<artMlaOp> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op3 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op4 = this.matchregOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.artMlaOp, op1: $scope$op1, op2: $scope$op2, op3: $scope$op3, op4: $scope$op4};
                }
                return $$res;
            });
    }
    public matchlog($$dpth: number, $$cr?: ErrorTracker): Nullable<log> {
        return this.choice<log>([
            () => this.matchlog_1($$dpth + 1, $$cr),
            () => this.matchlog_2($$dpth + 1, $$cr),
        ]);
    }
    public matchlog_1($$dpth: number, $$cr?: ErrorTracker): Nullable<log_1> {
        return this.run<log_1>($$dpth,
            () => {
                let $scope$inst: Nullable<logInst>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<logOp>;
                let $$res: Nullable<log_1> = null;
                if (true
                    && ($scope$inst = this.matchlogInst($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchlogOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.log_1, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchlog_2($$dpth: number, $$cr?: ErrorTracker): Nullable<log_2> {
        return this.run<log_2>($$dpth,
            () => {
                let $scope$inst: Nullable<logCmpInst>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<logOp2>;
                let $$res: Nullable<log_2> = null;
                if (true
                    && ($scope$inst = this.matchlogCmpInst($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchlogOp2($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.log_2, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchlogInst($$dpth: number, $$cr?: ErrorTracker): Nullable<logInst> {
        return this.choice<logInst>([
            () => this.matchlogInst_1($$dpth + 1, $$cr),
            () => this.matchlogInst_2($$dpth + 1, $$cr),
            () => this.matchlogInst_3($$dpth + 1, $$cr),
            () => this.matchlogInst_4($$dpth + 1, $$cr),
        ]);
    }
    public matchlogInst_1($$dpth: number, $$cr?: ErrorTracker): Nullable<logInst_1> {
        return this.regexAccept(String.raw`(?:and)`, $$dpth + 1, $$cr);
    }
    public matchlogInst_2($$dpth: number, $$cr?: ErrorTracker): Nullable<logInst_2> {
        return this.regexAccept(String.raw`(?:orr)`, $$dpth + 1, $$cr);
    }
    public matchlogInst_3($$dpth: number, $$cr?: ErrorTracker): Nullable<logInst_3> {
        return this.regexAccept(String.raw`(?:eor)`, $$dpth + 1, $$cr);
    }
    public matchlogInst_4($$dpth: number, $$cr?: ErrorTracker): Nullable<logInst_4> {
        return this.regexAccept(String.raw`(?:bic)`, $$dpth + 1, $$cr);
    }
    public matchlogCmpInst($$dpth: number, $$cr?: ErrorTracker): Nullable<logCmpInst> {
        return this.choice<logCmpInst>([
            () => this.matchlogCmpInst_1($$dpth + 1, $$cr),
            () => this.matchlogCmpInst_2($$dpth + 1, $$cr),
            () => this.matchlogCmpInst_3($$dpth + 1, $$cr),
            () => this.matchlogCmpInst_4($$dpth + 1, $$cr),
        ]);
    }
    public matchlogCmpInst_1($$dpth: number, $$cr?: ErrorTracker): Nullable<logCmpInst_1> {
        return this.regexAccept(String.raw`(?:cmp)`, $$dpth + 1, $$cr);
    }
    public matchlogCmpInst_2($$dpth: number, $$cr?: ErrorTracker): Nullable<logCmpInst_2> {
        return this.regexAccept(String.raw`(?:cmn)`, $$dpth + 1, $$cr);
    }
    public matchlogCmpInst_3($$dpth: number, $$cr?: ErrorTracker): Nullable<logCmpInst_3> {
        return this.regexAccept(String.raw`(?:tst)`, $$dpth + 1, $$cr);
    }
    public matchlogCmpInst_4($$dpth: number, $$cr?: ErrorTracker): Nullable<logCmpInst_4> {
        return this.regexAccept(String.raw`(?:teq)`, $$dpth + 1, $$cr);
    }
    public matchlogOp($$dpth: number, $$cr?: ErrorTracker): Nullable<logOp> {
        return this.choice<logOp>([
            () => this.matchlogOp_1($$dpth + 1, $$cr),
            () => this.matchlogOp_2($$dpth + 1, $$cr),
        ]);
    }
    public matchlogOp_1($$dpth: number, $$cr?: ErrorTracker): Nullable<logOp_1> {
        return this.matchlogOp3($$dpth + 1, $$cr);
    }
    public matchlogOp_2($$dpth: number, $$cr?: ErrorTracker): Nullable<logOp_2> {
        return this.matchlogOp2($$dpth + 1, $$cr);
    }
    public matchlogOp2($$dpth: number, $$cr?: ErrorTracker): Nullable<logOp2> {
        return this.run<logOp2>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<op>;
                let $$res: Nullable<logOp2> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchop($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.logOp2, op1: $scope$op1, op2: $scope$op2};
                }
                return $$res;
            });
    }
    public matchlogOp3($$dpth: number, $$cr?: ErrorTracker): Nullable<logOp3> {
        return this.run<logOp3>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<regOp>;
                let $scope$op3: Nullable<op>;
                let $$res: Nullable<logOp3> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op3 = this.matchop($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.logOp3, op1: $scope$op1, op2: $scope$op2, op3: $scope$op3};
                }
                return $$res;
            });
    }
    public matchcopyJump($$dpth: number, $$cr?: ErrorTracker): Nullable<copyJump> {
        return this.choice<copyJump>([
            () => this.matchcopyJump_1($$dpth + 1, $$cr),
            () => this.matchcopyJump_2($$dpth + 1, $$cr),
            () => this.matchcopyJump_3($$dpth + 1, $$cr),
        ]);
    }
    public matchcopyJump_1($$dpth: number, $$cr?: ErrorTracker): Nullable<copyJump_1> {
        return this.run<copyJump_1>($$dpth,
            () => {
                let $scope$inst: Nullable<copyInst>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<copyOp>;
                let $$res: Nullable<copyJump_1> = null;
                if (true
                    && ($scope$inst = this.matchcopyInst($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchcopyOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.copyJump_1, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchcopyJump_2($$dpth: number, $$cr?: ErrorTracker): Nullable<copyJump_2> {
        return this.run<copyJump_2>($$dpth,
            () => {
                let $scope$inst: Nullable<jumpInst1>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<jumpOp>;
                let $$res: Nullable<copyJump_2> = null;
                if (true
                    && ($scope$inst = this.matchjumpInst1($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchjumpOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.copyJump_2, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchcopyJump_3($$dpth: number, $$cr?: ErrorTracker): Nullable<copyJump_3> {
        return this.run<copyJump_3>($$dpth,
            () => {
                let $scope$inst: Nullable<jumpInst2>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<jumpOp>;
                let $$res: Nullable<copyJump_3> = null;
                if (true
                    && ($scope$inst = this.matchjumpInst2($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchjumpOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.copyJump_3, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchcopyInst($$dpth: number, $$cr?: ErrorTracker): Nullable<copyInst> {
        return this.choice<copyInst>([
            () => this.matchcopyInst_1($$dpth + 1, $$cr),
            () => this.matchcopyInst_2($$dpth + 1, $$cr),
        ]);
    }
    public matchcopyInst_1($$dpth: number, $$cr?: ErrorTracker): Nullable<copyInst_1> {
        return this.regexAccept(String.raw`(?:mov)`, $$dpth + 1, $$cr);
    }
    public matchcopyInst_2($$dpth: number, $$cr?: ErrorTracker): Nullable<copyInst_2> {
        return this.regexAccept(String.raw`(?:mvn)`, $$dpth + 1, $$cr);
    }
    public matchjumpInst1($$dpth: number, $$cr?: ErrorTracker): Nullable<jumpInst1> {
        return this.regexAccept(String.raw`(?:b)`, $$dpth + 1, $$cr);
    }
    public matchjumpInst2($$dpth: number, $$cr?: ErrorTracker): Nullable<jumpInst2> {
        return this.regexAccept(String.raw`(?:bl)`, $$dpth + 1, $$cr);
    }
    public matchcopyOp($$dpth: number, $$cr?: ErrorTracker): Nullable<copyOp> {
        return this.run<copyOp>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<op>;
                let $$res: Nullable<copyOp> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchop($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.copyOp, op1: $scope$op1, op2: $scope$op2};
                }
                return $$res;
            });
    }
    public matchjumpOp($$dpth: number, $$cr?: ErrorTracker): Nullable<jumpOp> {
        return this.run<jumpOp>($$dpth,
            () => {
                let $scope$op1: Nullable<branchOp>;
                let $$res: Nullable<jumpOp> = null;
                if (true
                    && ($scope$op1 = this.matchbranchOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.jumpOp, op1: $scope$op1};
                }
                return $$res;
            });
    }
    public matchloadStore($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStore> {
        return this.choice<loadStore>([
            () => this.matchloadStore_1($$dpth + 1, $$cr),
            () => this.matchloadStore_2($$dpth + 1, $$cr),
            () => this.matchloadStore_3($$dpth + 1, $$cr),
        ]);
    }
    public matchloadStore_1($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStore_1> {
        return this.run<loadStore_1>($$dpth,
            () => {
                let $scope$inst: Nullable<loadStoreInst>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<loadStoreOp>;
                let $$res: Nullable<loadStore_1> = null;
                if (true
                    && ($scope$inst = this.matchloadStoreInst($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchloadStoreOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.loadStore_1, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchloadStore_2($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStore_2> {
        return this.run<loadStore_2>($$dpth,
            () => {
                let $scope$inst: Nullable<loadStoreInst>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<loadImmediateOp>;
                let $$res: Nullable<loadStore_2> = null;
                if (true
                    && ($scope$inst = this.matchloadStoreInst($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchloadImmediateOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.loadStore_2, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchloadStore_3($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStore_3> {
        return this.run<loadStore_3>($$dpth,
            () => {
                let $scope$inst: Nullable<loadStoreInst>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<loadImmediateBranchOp>;
                let $$res: Nullable<loadStore_3> = null;
                if (true
                    && ($scope$inst = this.matchloadStoreInst($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchloadImmediateBranchOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.loadStore_3, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchloadStoreInst($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStoreInst> {
        return this.choice<loadStoreInst>([
            () => this.matchloadStoreInst_1($$dpth + 1, $$cr),
            () => this.matchloadStoreInst_2($$dpth + 1, $$cr),
        ]);
    }
    public matchloadStoreInst_1($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStoreInst_1> {
        return this.regexAccept(String.raw`(?:ldr)`, $$dpth + 1, $$cr);
    }
    public matchloadStoreInst_2($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStoreInst_2> {
        return this.regexAccept(String.raw`(?:str)`, $$dpth + 1, $$cr);
    }
    public matchloadStoreOp($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStoreOp> {
        return this.run<loadStoreOp>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<addressingMode>;
                let $$res: Nullable<loadStoreOp> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchaddressingMode($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.loadStoreOp, op1: $scope$op1, op2: $scope$op2};
                }
                return $$res;
            });
    }
    public matchloadImmediateOp($$dpth: number, $$cr?: ErrorTracker): Nullable<loadImmediateOp> {
        return this.run<loadImmediateOp>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<immOp>;
                let $$res: Nullable<loadImmediateOp> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchimmOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.loadImmediateOp, op1: $scope$op1, op2: $scope$op2};
                }
                return $$res;
            });
    }
    public matchloadImmediateBranchOp($$dpth: number, $$cr?: ErrorTracker): Nullable<loadImmediateBranchOp> {
        return this.run<loadImmediateBranchOp>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<branchOp>;
                let $$res: Nullable<loadImmediateBranchOp> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:=)`, $$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchbranchOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.loadImmediateBranchOp, op1: $scope$op1, op2: $scope$op2};
                }
                return $$res;
            });
    }
    public matchsoftwareInterrupt($$dpth: number, $$cr?: ErrorTracker): Nullable<softwareInterrupt> {
        return this.run<softwareInterrupt>($$dpth,
            () => {
                let $scope$inst: Nullable<string>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<string>;
                let $$res: Nullable<softwareInterrupt> = null;
                if (true
                    && ($scope$inst = this.regexAccept(String.raw`(?:swi)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.regexAccept(String.raw`(?:#0)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.softwareInterrupt, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchop($$dpth: number, $$cr?: ErrorTracker): Nullable<op> {
        return this.choice<op>([
            () => this.matchop_1($$dpth + 1, $$cr),
            () => this.matchop_2($$dpth + 1, $$cr),
        ]);
    }
    public matchop_1($$dpth: number, $$cr?: ErrorTracker): Nullable<op_1> {
        return this.run<op_1>($$dpth,
            () => {
                let $scope$shiftOp: Nullable<shiftOp>;
                let $$res: Nullable<op_1> = null;
                if (true
                    && ($scope$shiftOp = this.matchshiftOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.op_1, shiftOp: $scope$shiftOp};
                }
                return $$res;
            });
    }
    public matchop_2($$dpth: number, $$cr?: ErrorTracker): Nullable<op_2> {
        return this.run<op_2>($$dpth,
            () => {
                let $scope$regImmOp: Nullable<regImmOp>;
                let $$res: Nullable<op_2> = null;
                if (true
                    && ($scope$regImmOp = this.matchregImmOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.op_2, regImmOp: $scope$regImmOp};
                }
                return $$res;
            });
    }
    public matchregImmOp($$dpth: number, $$cr?: ErrorTracker): Nullable<regImmOp> {
        return this.choice<regImmOp>([
            () => this.matchregImmOp_1($$dpth + 1, $$cr),
            () => this.matchregImmOp_2($$dpth + 1, $$cr),
        ]);
    }
    public matchregImmOp_1($$dpth: number, $$cr?: ErrorTracker): Nullable<regImmOp_1> {
        return this.run<regImmOp_1>($$dpth,
            () => {
                let $scope$regOp: Nullable<regOp>;
                let $$res: Nullable<regImmOp_1> = null;
                if (true
                    && ($scope$regOp = this.matchregOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.regImmOp_1, regOp: $scope$regOp};
                }
                return $$res;
            });
    }
    public matchregImmOp_2($$dpth: number, $$cr?: ErrorTracker): Nullable<regImmOp_2> {
        return this.run<regImmOp_2>($$dpth,
            () => {
                let $scope$immOp: Nullable<immOp>;
                let $$res: Nullable<regImmOp_2> = null;
                if (true
                    && ($scope$immOp = this.matchimmOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.regImmOp_2, immOp: $scope$immOp};
                }
                return $$res;
            });
    }
    public matchshiftOp($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftOp> {
        return this.run<shiftOp>($$dpth,
            () => {
                let $scope$opToShift: Nullable<regImmOp>;
                let $scope$shiftType: Nullable<shiftType>;
                let $scope$opShift: Nullable<regImmOp>;
                let $$res: Nullable<shiftOp> = null;
                if (true
                    && ($scope$opToShift = this.matchregImmOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$shiftType = this.matchshiftType($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$opShift = this.matchregImmOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.shiftOp, opToShift: $scope$opToShift, shiftType: $scope$shiftType, opShift: $scope$opShift};
                }
                return $$res;
            });
    }
    public matchaddressingMode($$dpth: number, $$cr?: ErrorTracker): Nullable<addressingMode> {
        return this.choice<addressingMode>([
            () => this.matchaddressingMode_1($$dpth + 1, $$cr),
            () => this.matchaddressingMode_2($$dpth + 1, $$cr),
        ]);
    }
    public matchaddressingMode_1($$dpth: number, $$cr?: ErrorTracker): Nullable<addressingMode_1> {
        return this.run<addressingMode_1>($$dpth,
            () => {
                let $scope$reg: Nullable<regOp>;
                let $scope$offset: Nullable<Nullable<offset>>;
                let $$res: Nullable<addressingMode_1> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\[)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$reg = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\])`, $$dpth + 1, $$cr) !== null
                    && (($scope$offset = this.matchoffset($$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.addressingMode_1, reg: $scope$reg, offset: $scope$offset};
                }
                return $$res;
            });
    }
    public matchaddressingMode_2($$dpth: number, $$cr?: ErrorTracker): Nullable<addressingMode_2> {
        return this.run<addressingMode_2>($$dpth,
            () => {
                let $scope$reg: Nullable<regOp>;
                let $scope$offset: Nullable<Nullable<offset>>;
                let $scope$increment: Nullable<Nullable<string>>;
                let $$res: Nullable<addressingMode_2> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\[)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$reg = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && (($scope$offset = this.matchoffset($$dpth + 1, $$cr)) || true)
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\])`, $$dpth + 1, $$cr) !== null
                    && (($scope$increment = this.regexAccept(String.raw`(?:!)`, $$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.addressingMode_2, reg: $scope$reg, offset: $scope$offset, increment: $scope$increment};
                }
                return $$res;
            });
    }
    public matchoffset($$dpth: number, $$cr?: ErrorTracker): Nullable<offset> {
        return this.run<offset>($$dpth,
            () => {
                let $scope$sign: Nullable<sign>;
                let $scope$offset: Nullable<op>;
                let $$res: Nullable<offset> = null;
                if (true
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$sign = this.matchsign($$dpth + 1, $$cr)) !== null
                    && ($scope$offset = this.matchop($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.offset, sign: $scope$sign, offset: $scope$offset};
                }
                return $$res;
            });
    }
    public matchregOp($$dpth: number, $$cr?: ErrorTracker): Nullable<regOp> {
        return this.choice<regOp>([
            () => this.matchregOp_1($$dpth + 1, $$cr),
            () => this.matchregOp_2($$dpth + 1, $$cr),
            () => this.matchregOp_3($$dpth + 1, $$cr),
        ]);
    }
    public matchregOp_1($$dpth: number, $$cr?: ErrorTracker): Nullable<regOp_1> {
        return this.run<regOp_1>($$dpth,
            () => {
                let $scope$regOp: Nullable<string>;
                let $$res: Nullable<regOp_1> = null;
                if (true
                    && ($scope$regOp = this.regexAccept(String.raw`(?:r[0-9]+)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.regOp_1, regOp: $scope$regOp};
                }
                return $$res;
            });
    }
    public matchregOp_2($$dpth: number, $$cr?: ErrorTracker): Nullable<regOp_2> {
        return this.regexAccept(String.raw`(?:pc)`, $$dpth + 1, $$cr);
    }
    public matchregOp_3($$dpth: number, $$cr?: ErrorTracker): Nullable<regOp_3> {
        return this.regexAccept(String.raw`(?:lr)`, $$dpth + 1, $$cr);
    }
    public matchimmOp($$dpth: number, $$cr?: ErrorTracker): Nullable<immOp> {
        return this.run<immOp>($$dpth,
            () => {
                let $scope$immType: Nullable<immType>;
                let $scope$sign: Nullable<sign>;
                let $scope$base: Nullable<base>;
                let $scope$number: Nullable<string>;
                let $$res: Nullable<immOp> = null;
                if (true
                    && ($scope$immType = this.matchimmType($$dpth + 1, $$cr)) !== null
                    && ($scope$sign = this.matchsign($$dpth + 1, $$cr)) !== null
                    && ($scope$base = this.matchbase($$dpth + 1, $$cr)) !== null
                    && ($scope$number = this.regexAccept(String.raw`(?:[0-9a-f]+)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.immOp, immType: $scope$immType, sign: $scope$sign, base: $scope$base, number: $scope$number};
                }
                return $$res;
            });
    }
    public matchimmType($$dpth: number, $$cr?: ErrorTracker): Nullable<immType> {
        return this.choice<immType>([
            () => this.matchimmType_1($$dpth + 1, $$cr),
            () => this.matchimmType_2($$dpth + 1, $$cr),
        ]);
    }
    public matchimmType_1($$dpth: number, $$cr?: ErrorTracker): Nullable<immType_1> {
        return this.regexAccept(String.raw`(?:#)`, $$dpth + 1, $$cr);
    }
    public matchimmType_2($$dpth: number, $$cr?: ErrorTracker): Nullable<immType_2> {
        return this.regexAccept(String.raw`(?:=)`, $$dpth + 1, $$cr);
    }
    public matchbase($$dpth: number, $$cr?: ErrorTracker): Nullable<base> {
        return this.choice<base>([
            () => this.matchbase_1($$dpth + 1, $$cr),
            () => this.matchbase_2($$dpth + 1, $$cr),
            () => this.matchbase_3($$dpth + 1, $$cr),
            () => this.matchbase_4($$dpth + 1, $$cr),
        ]);
    }
    public matchbase_1($$dpth: number, $$cr?: ErrorTracker): Nullable<base_1> {
        return this.regexAccept(String.raw`(?:0x)`, $$dpth + 1, $$cr);
    }
    public matchbase_2($$dpth: number, $$cr?: ErrorTracker): Nullable<base_2> {
        return this.regexAccept(String.raw`(?:0b)`, $$dpth + 1, $$cr);
    }
    public matchbase_3($$dpth: number, $$cr?: ErrorTracker): Nullable<base_3> {
        return this.regexAccept(String.raw`(?:0o)`, $$dpth + 1, $$cr);
    }
    public matchbase_4($$dpth: number, $$cr?: ErrorTracker): Nullable<base_4> {
        return this.regexAccept(String.raw`(?:)`, $$dpth + 1, $$cr);
    }
    public matchsign($$dpth: number, $$cr?: ErrorTracker): Nullable<sign> {
        return this.choice<sign>([
            () => this.matchsign_1($$dpth + 1, $$cr),
            () => this.matchsign_2($$dpth + 1, $$cr),
            () => this.matchsign_3($$dpth + 1, $$cr),
        ]);
    }
    public matchsign_1($$dpth: number, $$cr?: ErrorTracker): Nullable<sign_1> {
        return this.regexAccept(String.raw`(?:-)`, $$dpth + 1, $$cr);
    }
    public matchsign_2($$dpth: number, $$cr?: ErrorTracker): Nullable<sign_2> {
        return this.regexAccept(String.raw`(?:\+)`, $$dpth + 1, $$cr);
    }
    public matchsign_3($$dpth: number, $$cr?: ErrorTracker): Nullable<sign_3> {
        return this.regexAccept(String.raw`(?:)`, $$dpth + 1, $$cr);
    }
    public matchbranchOp($$dpth: number, $$cr?: ErrorTracker): Nullable<branchOp> {
        return this.regexAccept(String.raw`(?:[_A-Za-z0-9]+)`, $$dpth + 1, $$cr);
    }
    public matchshiftType($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftType> {
        return this.choice<shiftType>([
            () => this.matchshiftType_1($$dpth + 1, $$cr),
            () => this.matchshiftType_2($$dpth + 1, $$cr),
            () => this.matchshiftType_3($$dpth + 1, $$cr),
            () => this.matchshiftType_4($$dpth + 1, $$cr),
            () => this.matchshiftType_5($$dpth + 1, $$cr),
            () => this.matchshiftType_6($$dpth + 1, $$cr),
        ]);
    }
    public matchshiftType_1($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftType_1> {
        return this.regexAccept(String.raw`(?:lsl)`, $$dpth + 1, $$cr);
    }
    public matchshiftType_2($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftType_2> {
        return this.regexAccept(String.raw`(?:asl)`, $$dpth + 1, $$cr);
    }
    public matchshiftType_3($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftType_3> {
        return this.regexAccept(String.raw`(?:lsr)`, $$dpth + 1, $$cr);
    }
    public matchshiftType_4($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftType_4> {
        return this.regexAccept(String.raw`(?:asr)`, $$dpth + 1, $$cr);
    }
    public matchshiftType_5($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftType_5> {
        return this.regexAccept(String.raw`(?:ror)`, $$dpth + 1, $$cr);
    }
    public matchshiftType_6($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftType_6> {
        return this.regexAccept(String.raw`(?:rrx)`, $$dpth + 1, $$cr);
    }
    public matchcondition($$dpth: number, $$cr?: ErrorTracker): Nullable<condition> {
        return this.run<condition>($$dpth,
            () => {
                let $scope$condType: Nullable<conditionType>;
                let $scope$updateStatusReg: Nullable<Nullable<string>>;
                let $$res: Nullable<condition> = null;
                if (true
                    && ($scope$condType = this.matchconditionType($$dpth + 1, $$cr)) !== null
                    && (($scope$updateStatusReg = this.regexAccept(String.raw`(?:s)`, $$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.condition, condType: $scope$condType, updateStatusReg: $scope$updateStatusReg};
                }
                return $$res;
            });
    }
    public matchconditionType($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType> {
        return this.choice<conditionType>([
            () => this.matchconditionType_1($$dpth + 1, $$cr),
            () => this.matchconditionType_2($$dpth + 1, $$cr),
            () => this.matchconditionType_3($$dpth + 1, $$cr),
            () => this.matchconditionType_4($$dpth + 1, $$cr),
            () => this.matchconditionType_5($$dpth + 1, $$cr),
            () => this.matchconditionType_6($$dpth + 1, $$cr),
            () => this.matchconditionType_7($$dpth + 1, $$cr),
            () => this.matchconditionType_8($$dpth + 1, $$cr),
            () => this.matchconditionType_9($$dpth + 1, $$cr),
            () => this.matchconditionType_10($$dpth + 1, $$cr),
            () => this.matchconditionType_11($$dpth + 1, $$cr),
            () => this.matchconditionType_12($$dpth + 1, $$cr),
            () => this.matchconditionType_13($$dpth + 1, $$cr),
            () => this.matchconditionType_14($$dpth + 1, $$cr),
            () => this.matchconditionType_15($$dpth + 1, $$cr),
            () => this.matchconditionType_16($$dpth + 1, $$cr),
            () => this.matchconditionType_17($$dpth + 1, $$cr),
            () => this.matchconditionType_18($$dpth + 1, $$cr),
            () => this.matchconditionType_19($$dpth + 1, $$cr),
        ]);
    }
    public matchconditionType_1($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_1> {
        return this.regexAccept(String.raw`(?:eq)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_2($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_2> {
        return this.regexAccept(String.raw`(?:ne)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_3($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_3> {
        return this.regexAccept(String.raw`(?:hs)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_4($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_4> {
        return this.regexAccept(String.raw`(?:cs)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_5($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_5> {
        return this.regexAccept(String.raw`(?:lo)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_6($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_6> {
        return this.regexAccept(String.raw`(?:cc)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_7($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_7> {
        return this.regexAccept(String.raw`(?:mi)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_8($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_8> {
        return this.regexAccept(String.raw`(?:pl)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_9($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_9> {
        return this.regexAccept(String.raw`(?:vs)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_10($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_10> {
        return this.regexAccept(String.raw`(?:vc)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_11($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_11> {
        return this.regexAccept(String.raw`(?:hi)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_12($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_12> {
        return this.regexAccept(String.raw`(?:ls)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_13($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_13> {
        return this.regexAccept(String.raw`(?:ge)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_14($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_14> {
        return this.regexAccept(String.raw`(?:lt)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_15($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_15> {
        return this.regexAccept(String.raw`(?:gt)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_16($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_16> {
        return this.regexAccept(String.raw`(?:le)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_17($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_17> {
        return this.regexAccept(String.raw`(?:al)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_18($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_18> {
        return this.regexAccept(String.raw`(?:nv)`, $$dpth + 1, $$cr);
    }
    public matchconditionType_19($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_19> {
        return this.regexAccept(String.raw`(?:)`, $$dpth + 1, $$cr);
    }
    public matchws($$dpth: number, $$cr?: ErrorTracker): Nullable<ws> {
        return this.regexAccept(String.raw`(?:[ \t]+)`, $$dpth + 1, $$cr);
    }
    public matchwso($$dpth: number, $$cr?: ErrorTracker): Nullable<wso> {
        return this.regexAccept(String.raw`(?:[ \t]*)`, $$dpth + 1, $$cr);
    }
    public matchnend($$dpth: number, $$cr?: ErrorTracker): Nullable<nend> {
        return this.choice<nend>([
            () => this.matchnend_1($$dpth + 1, $$cr),
            () => this.matchnend_2($$dpth + 1, $$cr),
        ]);
    }
    public matchnend_1($$dpth: number, $$cr?: ErrorTracker): Nullable<nend_1> {
        return this.regexAccept(String.raw`(?:\n)`, $$dpth + 1, $$cr);
    }
    public matchnend_2($$dpth: number, $$cr?: ErrorTracker): Nullable<nend_2> {
        return this.match$EOF($$cr);
    }
    public test(): boolean {
        const mrk = this.mark();
        const res = this.matchstart(0);
        const ans = res !== null;
        this.reset(mrk);
        return ans;
    }
    public parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchstart(0);
        if (res)
            return {ast: res, errs: []};
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.clearMemos();
        this.matchstart(0, rec);
        const err = rec.getErr()
        return {ast: res, errs: err !== null ? [err] : []}
    }
    public mark(): PosInfo {
        return this.pos;
    }
    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        for (;;) {
            const t = func();
            if (t === null) {
                break;
            }
            res.push(t);
        }
        if (star || res.length > 0) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn()
        if (res !== null)
            return res;
        this.reset(mrk);
        return null;
    }
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, dpth: number, cr?: ErrorTracker): Nullable<string> {
        return this.run<string>(dpth,
            () => {
                const reg = new RegExp(match, "y");
                const mrk = this.mark();
                reg.lastIndex = mrk.overallPos;
                const res = this.tryConsume(reg);
                if(cr) {
                    cr.record(mrk, res, {
                        kind: "RegexMatch",
                        // We substring from 3 to len - 1 to strip off the
                        // non-capture group syntax added as a WebKit workaround
                        literal: match.substring(3, match.length - 1),
                        negated: this.negating,
                    });
                }
                return res;
            });
    }
    private tryConsume(reg: RegExp): Nullable<string> {
        const res = reg.exec(this.input);
        if (res) {
            let lineJmp = 0;
            let lind = -1;
            for (let i = 0; i < res[0].length; ++i) {
                if (res[0][i] === "\n") {
                    ++lineJmp;
                    lind = i;
                }
            }
            this.pos = {
                overallPos: reg.lastIndex,
                line: this.pos.line + lineJmp,
                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)
            };
            return res[0];
        }
        return null;
    }
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {
        const $scope$pos = this.mark();
        const $scope$memoRes = memo.get($scope$pos.overallPos);
        if(this.memoSafe && $scope$memoRes !== undefined) {
        this.reset($scope$memoRes[1]);
        return $scope$memoRes[0];
        }
        const $scope$result = rule();
        if(this.memoSafe)
        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);
        return $scope$result;
    }
    private match$EOF(et?: ErrorTracker): Nullable<{kind: ASTKinds.$EOF}> {
        const res: {kind: ASTKinds.$EOF} | null = this.finished() ? { kind: ASTKinds.$EOF } : null;
        if(et)
            et.record(this.mark(), res, { kind: "EOF", negated: this.negating });
        return res;
    }
}
export function parse(s: string): ParseResult {
    const p = new Parser(s);
    return p.parse();
}
export interface ParseResult {
    ast: Nullable<start>;
    errs: SyntaxErr[];
}
export interface PosInfo {
    readonly overallPos: number;
    readonly line: number;
    readonly offset: number;
}
export interface RegexMatch {
    readonly kind: "RegexMatch";
    readonly negated: boolean;
    readonly literal: string;
}
export type EOFMatch = { kind: "EOF"; negated: boolean };
export type MatchAttempt = RegexMatch | EOFMatch;
export class SyntaxErr {
    public pos: PosInfo;
    public expmatches: MatchAttempt[];
    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {
        this.pos = pos;
        this.expmatches = [...expmatches];
    }
    public toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === "EOF" ? " EOF" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;
    }
}
class ErrorTracker {
    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};
    private regexset: Set<string> = new Set();
    private pmatches: MatchAttempt[] = [];
    public record(pos: PosInfo, result: any, att: MatchAttempt) {
        if ((result === null) === att.negated)
            return;
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.pmatches = [];
            this.regexset.clear()
        }
        if (this.mxpos.overallPos === pos.overallPos) {
            if(att.kind === "RegexMatch") {
                if(!this.regexset.has(att.literal))
                    this.pmatches.push(att);
                this.regexset.add(att.literal);
            } else {
                this.pmatches.push(att);
            }
        }
    }
    public getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1)
            return new SyntaxErr(this.mxpos, this.pmatches);
        return null;
    }
}