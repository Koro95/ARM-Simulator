/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* // tsPEG doesn't allow all properties of regular expressions,
* // so cannot use the one to ignore case. Therefore changed
* // all direct word like '.text' to '.[tT][eE][xX][tT]' with
* // a python script. Before tried to convert the user input
* // to lower case, before parsing. But this messed with the
* // .ascii content with upper case letters.
* start := start=line
* // grammar split into individual lines with 4 different
* // contents in currentLine. '[\s]*' handles empty lines
* // between lines with content
* line := '[\s]*' label=label? '[\s]*' currentLine=directive wso
*          comment=comment? nend nextLine=line |
*         '[\s]*' label=label? '[\s]*' currentLine=instruction wso
*          comment=comment? nend nextLine=line |
*         '[\s]*' label=label? '[\s]*' currentLine=variableLine
*          nend nextLine=line |
*         '[\s]*' label=label? '[\s]*' currentLine=commentLine
*          nend nextLine=line |
*         '[\s]*' $
* // 1. all directives the parser knows
* directive := directive=ascii |
*              directive=space |
*              directive='.[aA][rR][mM]' |
*              directive='.[tT][eE][xX][tT]' |
*              directive='.[dD][aA][tT][aA]' |
*              directive='.[aA][lL][iI][gG][nN]' |
*              directive='.[gG][lL][oO][bB][aA][lL]' ws
*                        '_[sS][tT][aA][rR][tT]'
* // directives where additional information need to be stored
* ascii := '.[aA][sS][cC][iI][iI]' ws '"' data='[ -!#-~]*' '"'
* space := '.[sS][pP][aA][cC][eE]' ws size='[0-9]+'
* // 2. all instruction the parser knows further divided
* //    into instruction types
* instruction := instruction=art |
*                instruction=log |
*                instruction=copyJump |
*                instruction=loadStore |
*                instruction=loadStoreMultiple |
*                instruction=softwareInterrupt
* // 3. lines with variables, like after ascii "len = . - msg
* variableLine := variable='[_A-Za-z][_A-Za-z0-9]*' wso '=' wso
*                 '.' wso '-' wso label='[_A-Za-z][_A-Za-z0-9]*'
* // 4. line with only a comment
* commentLine := commentLine=comment
* // optional label and comment for each line
* label := label='[_A-Za-z][_A-Za-z0-9]*' ':'
* comment := comment='//[ \t\S]*' | comment='\/\*[\s -.0-~öäüß]*\*\/'
* //--------------------------------------------------------------------
* // arithmetic or multiplication instructions
* art := inst=artInst cond=condition ws operands=artOp |
*        inst='[mM][uU][lL]' cond=condition ws operands=artMulOp |
*        inst='[mM][lL][aA]' cond=condition ws operands=artMlaOp
* // known arithmetic instructions
* artInst := '[aA][dD][dD]' | '[aA][dD][cC]' | '[sS][uU][bB]' |
*            '[sS][bB][cC]' | '[rR][sS][bB]' | '[rR][sS][cC]'
* // different kinds of operands for arithmetic instructions
* artOp := artOp3 | artOp2
* artOp2 := op1=regOp wso ',' wso op2=op
* artOp3 := op1=regOp wso ',' wso op2=regOp wso ',' wso op3=op
* // different kinds of operands for multiplication instructions
* artMulOp := op1=regOp wso ',' wso op2=regOp wso ',' wso op3=regOp
* artMlaOp := op1=regOp wso ',' wso op2=regOp wso ',' wso op3=regOp
*             wso ',' wso op4=regOp
* //--------------------------------------------------------------------
* // logic instructions
* log := inst=logInst cond=condition ws operands=logOp |
*        inst=logCmpInst cond=condition ws operands=logOp2
* // known logic instructions
* logInst := '[aA][nN][dD]' | '[oO][rR][rR]' |
*            '[eE][oO][rR]' | '[bB][iI][cC]'
* logCmpInst := '[cC][mM][pP]' | '[cC][mM][nN]' |
*               '[tT][sS][tT]' | '[tT][eE][qQ]'
* // different kinds of operands for logic instructions
* logOp := logOp3 | logOp2
* logOp2 := op1=regOp wso ',' wso op2=op
* logOp3 := op1=regOp wso ',' wso op2=regOp wso ',' wso op3=op
* //--------------------------------------------------------------------
* // copy or jump instructions
* copyJump := inst=copyInst cond=condition ws operands=copyOp |
*             inst=jumpInst1 cond=condition ws operands=jumpOp |
*             inst=jumpInst2 cond=condition ws operands=jumpOp
* // known copy or jump instructions
* copyInst := '[mM][oO][vV]' | '[mM][vV][nN]'
* jumpInst1 := '[bB]'
* jumpInst2 := '[bB][lL]'
* // different kinds of operands for copy or jump instructions
* copyOp := op1=regOp wso ',' wso op2=op
* jumpOp := op1=branchOp
* //--------------------------------------------------------------------
* // load/store/swap instructions
* loadStore := inst=loadStoreInst format=format cond=condition ws
*              operands=loadStoreOp |
*              inst='[sS][wW][pP]' format=format cond=condition ws
*              operands=swpOp |
*              inst=loadStoreInst cond=condition ws
*              operands=loadImmediateBranchOp |
*              inst=loadStoreInst cond=condition ws
*              operands=loadImmediateOp
* // known load/store instructions and formats
* loadStoreInst := '[lL][dD][rR]' | '[sS][tT][rR]'
* format := '[bB]' | '[hH]' | '[sS][bB]' | '[sS][hH]' | ''
* // different kinds of operands for load/store/swap instructions
* loadStoreOp := op1=regOp wso ',' wso op2=addressingMode
* swpOp := op1=regOp wso ',' wso op2=regOp wso ',' wso
*          '\[' wso op3=regOp wso '\]'
* loadImmediateOp := op1=regOp wso ',' wso op2=immOp
* loadImmediateBranchOp := op1=regOp wso ',' wso '=' op2=branchOp
*                          offset='[+-][0-9]+'?
* //--------------------------------------------------------------------
* // load/store multiple instructions
* loadStoreMultiple := inst=loadStoreMultipleInst
*                      addressingMode=loadStoreMultipleAddrMode
*                      cond=condition ws operands=loadStoreMultipleOp
* // known load/store multiple instructions and format
* loadStoreMultipleInst := '[lL][dD][mM]' | '[sS][tT][mM]'
* loadStoreMultipleAddrMode := '[fF][dD]' | '[fF][aA]' | '[eE][dD]' |
*                              '[eE][aA]' | '[iI][aA]' | '[iI][bB]' |
*                              '[dD][aA]' | '[dD][bB]' | ''
* // different kinds of operands for load/store multiple instructions
* loadStoreMultipleOp := op1=regOp increment='!'? wso ',' wso
*                        '{' wso op2=regOpList wso '}'
* //--------------------------------------------------------------------
* // software interrupts
* softwareInterrupt := inst='[sS][wW][iI]' cond=condition ws
*                      operands='#0'
* //--------------------------------------------------------------------
* // all operands for the instructions
* // combinations of allows register, immediate and shifter operands
* // for data-processing instructions
* op := shiftOp=shiftOp | regImmOp=regImmOp
* regImmOp := regOp=regOp | immOp=immOp
* shiftOp := opToShift=regImmOp wso ',' wso shiftType=shiftType wso
*            opShift=regImmOp
* // addressing operands for load/store
* addressingMode := '\[' wso reg=regOp wso '\]' offset=offset? |
*                    '\[' wso reg=regOp offset=offset? wso '\]'
*                    increment='!'?
*                    
* offset := wso ',' wso sign=sign offset=op
* // register operand
* regOp := regOp='[rR][0-9]+' | '[pP][cC]' | '[lL][rR]' | '[sS][pP]'
* // immediate operand
* immOp := immType=immType sign=sign base=base number='[0-9a-fA-F]+'
* immType := '#' | '='
* base := '0[xX]' | '0[bB]' | '0[oO]' | ''
* sign := '-' | '\+' | ''
* // branch operand
* branchOp := '[_A-Za-z][_A-Za-z0-9]*'
* // list of register operands for load/store multiple
* regOpList := op=regOpOrRange wso ',' wso nextOp=regOpList |
*              op=regOpOrRange
* regOpRange := op1=regOp wso '-' wso op2=regOp
* regOpOrRange := op=regOpRange | op=regOp
* // known shift types
* shiftType := '[lL][sS][lL]' | '[aA][sS][lL]' | '[lL][sS][rR]' |
*              '[aA][sS][rR]' | '[rR][oO][rR]' | '[rR][rR][xX]'
* // conditions and S flag
* condition := condType=conditionType updateStatusReg='[sS]'?
* // known condition types
* conditionType := '[eE][qQ]' | '[nN][eE]' | '[hH][sS]' | '[cC][sS]' |
*                  '[lL][oO]' | '[cC][cC]' | '[mM][iI]' | '[pP][lL]' |
*                  '[vV][sS]' | '[vV][cC]' | '[hH][iI]' | '[lL][sS]' |
*                  '[gG][eE]' | '[lL][tT]' | '[gG][tT]' | '[lL][eE]' |
*                  '[aA][lL]' | '[nN][vV]' | ''
* //--------------------------------------------------------------------
* // white space no new line 
* ws := '[ \t]+'
* // optional white space no new line 
* wso := '[ \t]*'
* // new line or end of file
* nend := '\n' | $
*/
type Nullable<T> = T | null;
type $$RuleType<T> = () => Nullable<T>;
interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    start = "start",
    line_1 = "line_1",
    line_2 = "line_2",
    line_3 = "line_3",
    line_4 = "line_4",
    line_5 = "line_5",
    directive_1 = "directive_1",
    directive_2 = "directive_2",
    directive_3 = "directive_3",
    directive_4 = "directive_4",
    directive_5 = "directive_5",
    directive_6 = "directive_6",
    directive_7 = "directive_7",
    ascii = "ascii",
    space = "space",
    instruction_1 = "instruction_1",
    instruction_2 = "instruction_2",
    instruction_3 = "instruction_3",
    instruction_4 = "instruction_4",
    instruction_5 = "instruction_5",
    instruction_6 = "instruction_6",
    variableLine = "variableLine",
    commentLine = "commentLine",
    label = "label",
    comment_1 = "comment_1",
    comment_2 = "comment_2",
    art_1 = "art_1",
    art_2 = "art_2",
    art_3 = "art_3",
    artInst_1 = "artInst_1",
    artInst_2 = "artInst_2",
    artInst_3 = "artInst_3",
    artInst_4 = "artInst_4",
    artInst_5 = "artInst_5",
    artInst_6 = "artInst_6",
    artOp_1 = "artOp_1",
    artOp_2 = "artOp_2",
    artOp2 = "artOp2",
    artOp3 = "artOp3",
    artMulOp = "artMulOp",
    artMlaOp = "artMlaOp",
    log_1 = "log_1",
    log_2 = "log_2",
    logInst_1 = "logInst_1",
    logInst_2 = "logInst_2",
    logInst_3 = "logInst_3",
    logInst_4 = "logInst_4",
    logCmpInst_1 = "logCmpInst_1",
    logCmpInst_2 = "logCmpInst_2",
    logCmpInst_3 = "logCmpInst_3",
    logCmpInst_4 = "logCmpInst_4",
    logOp_1 = "logOp_1",
    logOp_2 = "logOp_2",
    logOp2 = "logOp2",
    logOp3 = "logOp3",
    copyJump_1 = "copyJump_1",
    copyJump_2 = "copyJump_2",
    copyJump_3 = "copyJump_3",
    copyInst_1 = "copyInst_1",
    copyInst_2 = "copyInst_2",
    jumpInst1 = "jumpInst1",
    jumpInst2 = "jumpInst2",
    copyOp = "copyOp",
    jumpOp = "jumpOp",
    loadStore_1 = "loadStore_1",
    loadStore_2 = "loadStore_2",
    loadStore_3 = "loadStore_3",
    loadStore_4 = "loadStore_4",
    loadStoreInst_1 = "loadStoreInst_1",
    loadStoreInst_2 = "loadStoreInst_2",
    format_1 = "format_1",
    format_2 = "format_2",
    format_3 = "format_3",
    format_4 = "format_4",
    format_5 = "format_5",
    loadStoreOp = "loadStoreOp",
    swpOp = "swpOp",
    loadImmediateOp = "loadImmediateOp",
    loadImmediateBranchOp = "loadImmediateBranchOp",
    loadStoreMultiple = "loadStoreMultiple",
    loadStoreMultipleInst_1 = "loadStoreMultipleInst_1",
    loadStoreMultipleInst_2 = "loadStoreMultipleInst_2",
    loadStoreMultipleAddrMode_1 = "loadStoreMultipleAddrMode_1",
    loadStoreMultipleAddrMode_2 = "loadStoreMultipleAddrMode_2",
    loadStoreMultipleAddrMode_3 = "loadStoreMultipleAddrMode_3",
    loadStoreMultipleAddrMode_4 = "loadStoreMultipleAddrMode_4",
    loadStoreMultipleAddrMode_5 = "loadStoreMultipleAddrMode_5",
    loadStoreMultipleAddrMode_6 = "loadStoreMultipleAddrMode_6",
    loadStoreMultipleAddrMode_7 = "loadStoreMultipleAddrMode_7",
    loadStoreMultipleAddrMode_8 = "loadStoreMultipleAddrMode_8",
    loadStoreMultipleAddrMode_9 = "loadStoreMultipleAddrMode_9",
    loadStoreMultipleOp = "loadStoreMultipleOp",
    softwareInterrupt = "softwareInterrupt",
    op_1 = "op_1",
    op_2 = "op_2",
    regImmOp_1 = "regImmOp_1",
    regImmOp_2 = "regImmOp_2",
    shiftOp = "shiftOp",
    addressingMode_1 = "addressingMode_1",
    addressingMode_2 = "addressingMode_2",
    offset = "offset",
    regOp_1 = "regOp_1",
    regOp_2 = "regOp_2",
    regOp_3 = "regOp_3",
    regOp_4 = "regOp_4",
    immOp = "immOp",
    immType_1 = "immType_1",
    immType_2 = "immType_2",
    base_1 = "base_1",
    base_2 = "base_2",
    base_3 = "base_3",
    base_4 = "base_4",
    sign_1 = "sign_1",
    sign_2 = "sign_2",
    sign_3 = "sign_3",
    branchOp = "branchOp",
    regOpList_1 = "regOpList_1",
    regOpList_2 = "regOpList_2",
    regOpRange = "regOpRange",
    regOpOrRange_1 = "regOpOrRange_1",
    regOpOrRange_2 = "regOpOrRange_2",
    shiftType_1 = "shiftType_1",
    shiftType_2 = "shiftType_2",
    shiftType_3 = "shiftType_3",
    shiftType_4 = "shiftType_4",
    shiftType_5 = "shiftType_5",
    shiftType_6 = "shiftType_6",
    condition = "condition",
    conditionType_1 = "conditionType_1",
    conditionType_2 = "conditionType_2",
    conditionType_3 = "conditionType_3",
    conditionType_4 = "conditionType_4",
    conditionType_5 = "conditionType_5",
    conditionType_6 = "conditionType_6",
    conditionType_7 = "conditionType_7",
    conditionType_8 = "conditionType_8",
    conditionType_9 = "conditionType_9",
    conditionType_10 = "conditionType_10",
    conditionType_11 = "conditionType_11",
    conditionType_12 = "conditionType_12",
    conditionType_13 = "conditionType_13",
    conditionType_14 = "conditionType_14",
    conditionType_15 = "conditionType_15",
    conditionType_16 = "conditionType_16",
    conditionType_17 = "conditionType_17",
    conditionType_18 = "conditionType_18",
    conditionType_19 = "conditionType_19",
    ws = "ws",
    wso = "wso",
    nend_1 = "nend_1",
    nend_2 = "nend_2",
    $EOF = "$EOF",
}
export interface start {
    kind: ASTKinds.start;
    start: line;
}
export type line = line_1 | line_2 | line_3 | line_4 | line_5;
export interface line_1 {
    kind: ASTKinds.line_1;
    label: Nullable<label>;
    currentLine: directive;
    comment: Nullable<comment>;
    nextLine: line;
}
export interface line_2 {
    kind: ASTKinds.line_2;
    label: Nullable<label>;
    currentLine: instruction;
    comment: Nullable<comment>;
    nextLine: line;
}
export interface line_3 {
    kind: ASTKinds.line_3;
    label: Nullable<label>;
    currentLine: variableLine;
    nextLine: line;
}
export interface line_4 {
    kind: ASTKinds.line_4;
    label: Nullable<label>;
    currentLine: commentLine;
    nextLine: line;
}
export interface line_5 {
    kind: ASTKinds.line_5;
}
export type directive = directive_1 | directive_2 | directive_3 | directive_4 | directive_5 | directive_6 | directive_7;
export interface directive_1 {
    kind: ASTKinds.directive_1;
    directive: ascii;
}
export interface directive_2 {
    kind: ASTKinds.directive_2;
    directive: space;
}
export interface directive_3 {
    kind: ASTKinds.directive_3;
    directive: string;
}
export interface directive_4 {
    kind: ASTKinds.directive_4;
    directive: string;
}
export interface directive_5 {
    kind: ASTKinds.directive_5;
    directive: string;
}
export interface directive_6 {
    kind: ASTKinds.directive_6;
    directive: string;
}
export interface directive_7 {
    kind: ASTKinds.directive_7;
    directive: string;
}
export interface ascii {
    kind: ASTKinds.ascii;
    data: string;
}
export interface space {
    kind: ASTKinds.space;
    size: string;
}
export type instruction = instruction_1 | instruction_2 | instruction_3 | instruction_4 | instruction_5 | instruction_6;
export interface instruction_1 {
    kind: ASTKinds.instruction_1;
    instruction: art;
}
export interface instruction_2 {
    kind: ASTKinds.instruction_2;
    instruction: log;
}
export interface instruction_3 {
    kind: ASTKinds.instruction_3;
    instruction: copyJump;
}
export interface instruction_4 {
    kind: ASTKinds.instruction_4;
    instruction: loadStore;
}
export interface instruction_5 {
    kind: ASTKinds.instruction_5;
    instruction: loadStoreMultiple;
}
export interface instruction_6 {
    kind: ASTKinds.instruction_6;
    instruction: softwareInterrupt;
}
export interface variableLine {
    kind: ASTKinds.variableLine;
    variable: string;
    label: string;
}
export interface commentLine {
    kind: ASTKinds.commentLine;
    commentLine: comment;
}
export interface label {
    kind: ASTKinds.label;
    label: string;
}
export type comment = comment_1 | comment_2;
export interface comment_1 {
    kind: ASTKinds.comment_1;
    comment: string;
}
export interface comment_2 {
    kind: ASTKinds.comment_2;
    comment: string;
}
export type art = art_1 | art_2 | art_3;
export interface art_1 {
    kind: ASTKinds.art_1;
    inst: artInst;
    cond: condition;
    operands: artOp;
}
export interface art_2 {
    kind: ASTKinds.art_2;
    inst: string;
    cond: condition;
    operands: artMulOp;
}
export interface art_3 {
    kind: ASTKinds.art_3;
    inst: string;
    cond: condition;
    operands: artMlaOp;
}
export type artInst = artInst_1 | artInst_2 | artInst_3 | artInst_4 | artInst_5 | artInst_6;
export type artInst_1 = string;
export type artInst_2 = string;
export type artInst_3 = string;
export type artInst_4 = string;
export type artInst_5 = string;
export type artInst_6 = string;
export type artOp = artOp_1 | artOp_2;
export type artOp_1 = artOp3;
export type artOp_2 = artOp2;
export interface artOp2 {
    kind: ASTKinds.artOp2;
    op1: regOp;
    op2: op;
}
export interface artOp3 {
    kind: ASTKinds.artOp3;
    op1: regOp;
    op2: regOp;
    op3: op;
}
export interface artMulOp {
    kind: ASTKinds.artMulOp;
    op1: regOp;
    op2: regOp;
    op3: regOp;
}
export interface artMlaOp {
    kind: ASTKinds.artMlaOp;
    op1: regOp;
    op2: regOp;
    op3: regOp;
    op4: regOp;
}
export type log = log_1 | log_2;
export interface log_1 {
    kind: ASTKinds.log_1;
    inst: logInst;
    cond: condition;
    operands: logOp;
}
export interface log_2 {
    kind: ASTKinds.log_2;
    inst: logCmpInst;
    cond: condition;
    operands: logOp2;
}
export type logInst = logInst_1 | logInst_2 | logInst_3 | logInst_4;
export type logInst_1 = string;
export type logInst_2 = string;
export type logInst_3 = string;
export type logInst_4 = string;
export type logCmpInst = logCmpInst_1 | logCmpInst_2 | logCmpInst_3 | logCmpInst_4;
export type logCmpInst_1 = string;
export type logCmpInst_2 = string;
export type logCmpInst_3 = string;
export type logCmpInst_4 = string;
export type logOp = logOp_1 | logOp_2;
export type logOp_1 = logOp3;
export type logOp_2 = logOp2;
export interface logOp2 {
    kind: ASTKinds.logOp2;
    op1: regOp;
    op2: op;
}
export interface logOp3 {
    kind: ASTKinds.logOp3;
    op1: regOp;
    op2: regOp;
    op3: op;
}
export type copyJump = copyJump_1 | copyJump_2 | copyJump_3;
export interface copyJump_1 {
    kind: ASTKinds.copyJump_1;
    inst: copyInst;
    cond: condition;
    operands: copyOp;
}
export interface copyJump_2 {
    kind: ASTKinds.copyJump_2;
    inst: jumpInst1;
    cond: condition;
    operands: jumpOp;
}
export interface copyJump_3 {
    kind: ASTKinds.copyJump_3;
    inst: jumpInst2;
    cond: condition;
    operands: jumpOp;
}
export type copyInst = copyInst_1 | copyInst_2;
export type copyInst_1 = string;
export type copyInst_2 = string;
export type jumpInst1 = string;
export type jumpInst2 = string;
export interface copyOp {
    kind: ASTKinds.copyOp;
    op1: regOp;
    op2: op;
}
export interface jumpOp {
    kind: ASTKinds.jumpOp;
    op1: branchOp;
}
export type loadStore = loadStore_1 | loadStore_2 | loadStore_3 | loadStore_4;
export interface loadStore_1 {
    kind: ASTKinds.loadStore_1;
    inst: loadStoreInst;
    format: format;
    cond: condition;
    operands: loadStoreOp;
}
export interface loadStore_2 {
    kind: ASTKinds.loadStore_2;
    inst: string;
    format: format;
    cond: condition;
    operands: swpOp;
}
export interface loadStore_3 {
    kind: ASTKinds.loadStore_3;
    inst: loadStoreInst;
    cond: condition;
    operands: loadImmediateBranchOp;
}
export interface loadStore_4 {
    kind: ASTKinds.loadStore_4;
    inst: loadStoreInst;
    cond: condition;
    operands: loadImmediateOp;
}
export type loadStoreInst = loadStoreInst_1 | loadStoreInst_2;
export type loadStoreInst_1 = string;
export type loadStoreInst_2 = string;
export type format = format_1 | format_2 | format_3 | format_4 | format_5;
export type format_1 = string;
export type format_2 = string;
export type format_3 = string;
export type format_4 = string;
export type format_5 = string;
export interface loadStoreOp {
    kind: ASTKinds.loadStoreOp;
    op1: regOp;
    op2: addressingMode;
}
export interface swpOp {
    kind: ASTKinds.swpOp;
    op1: regOp;
    op2: regOp;
    op3: regOp;
}
export interface loadImmediateOp {
    kind: ASTKinds.loadImmediateOp;
    op1: regOp;
    op2: immOp;
}
export interface loadImmediateBranchOp {
    kind: ASTKinds.loadImmediateBranchOp;
    op1: regOp;
    op2: branchOp;
    offset: Nullable<string>;
}
export interface loadStoreMultiple {
    kind: ASTKinds.loadStoreMultiple;
    inst: loadStoreMultipleInst;
    addressingMode: loadStoreMultipleAddrMode;
    cond: condition;
    operands: loadStoreMultipleOp;
}
export type loadStoreMultipleInst = loadStoreMultipleInst_1 | loadStoreMultipleInst_2;
export type loadStoreMultipleInst_1 = string;
export type loadStoreMultipleInst_2 = string;
export type loadStoreMultipleAddrMode = loadStoreMultipleAddrMode_1 | loadStoreMultipleAddrMode_2 | loadStoreMultipleAddrMode_3 | loadStoreMultipleAddrMode_4 | loadStoreMultipleAddrMode_5 | loadStoreMultipleAddrMode_6 | loadStoreMultipleAddrMode_7 | loadStoreMultipleAddrMode_8 | loadStoreMultipleAddrMode_9;
export type loadStoreMultipleAddrMode_1 = string;
export type loadStoreMultipleAddrMode_2 = string;
export type loadStoreMultipleAddrMode_3 = string;
export type loadStoreMultipleAddrMode_4 = string;
export type loadStoreMultipleAddrMode_5 = string;
export type loadStoreMultipleAddrMode_6 = string;
export type loadStoreMultipleAddrMode_7 = string;
export type loadStoreMultipleAddrMode_8 = string;
export type loadStoreMultipleAddrMode_9 = string;
export interface loadStoreMultipleOp {
    kind: ASTKinds.loadStoreMultipleOp;
    op1: regOp;
    increment: Nullable<string>;
    op2: regOpList;
}
export interface softwareInterrupt {
    kind: ASTKinds.softwareInterrupt;
    inst: string;
    cond: condition;
    operands: string;
}
export type op = op_1 | op_2;
export interface op_1 {
    kind: ASTKinds.op_1;
    shiftOp: shiftOp;
}
export interface op_2 {
    kind: ASTKinds.op_2;
    regImmOp: regImmOp;
}
export type regImmOp = regImmOp_1 | regImmOp_2;
export interface regImmOp_1 {
    kind: ASTKinds.regImmOp_1;
    regOp: regOp;
}
export interface regImmOp_2 {
    kind: ASTKinds.regImmOp_2;
    immOp: immOp;
}
export interface shiftOp {
    kind: ASTKinds.shiftOp;
    opToShift: regImmOp;
    shiftType: shiftType;
    opShift: regImmOp;
}
export type addressingMode = addressingMode_1 | addressingMode_2;
export interface addressingMode_1 {
    kind: ASTKinds.addressingMode_1;
    reg: regOp;
    offset: Nullable<offset>;
}
export interface addressingMode_2 {
    kind: ASTKinds.addressingMode_2;
    reg: regOp;
    offset: Nullable<offset>;
    increment: Nullable<string>;
}
export interface offset {
    kind: ASTKinds.offset;
    sign: sign;
    offset: op;
}
export type regOp = regOp_1 | regOp_2 | regOp_3 | regOp_4;
export interface regOp_1 {
    kind: ASTKinds.regOp_1;
    regOp: string;
}
export type regOp_2 = string;
export type regOp_3 = string;
export type regOp_4 = string;
export interface immOp {
    kind: ASTKinds.immOp;
    immType: immType;
    sign: sign;
    base: base;
    number: string;
}
export type immType = immType_1 | immType_2;
export type immType_1 = string;
export type immType_2 = string;
export type base = base_1 | base_2 | base_3 | base_4;
export type base_1 = string;
export type base_2 = string;
export type base_3 = string;
export type base_4 = string;
export type sign = sign_1 | sign_2 | sign_3;
export type sign_1 = string;
export type sign_2 = string;
export type sign_3 = string;
export type branchOp = string;
export type regOpList = regOpList_1 | regOpList_2;
export interface regOpList_1 {
    kind: ASTKinds.regOpList_1;
    op: regOpOrRange;
    nextOp: regOpList;
}
export interface regOpList_2 {
    kind: ASTKinds.regOpList_2;
    op: regOpOrRange;
}
export interface regOpRange {
    kind: ASTKinds.regOpRange;
    op1: regOp;
    op2: regOp;
}
export type regOpOrRange = regOpOrRange_1 | regOpOrRange_2;
export interface regOpOrRange_1 {
    kind: ASTKinds.regOpOrRange_1;
    op: regOpRange;
}
export interface regOpOrRange_2 {
    kind: ASTKinds.regOpOrRange_2;
    op: regOp;
}
export type shiftType = shiftType_1 | shiftType_2 | shiftType_3 | shiftType_4 | shiftType_5 | shiftType_6;
export type shiftType_1 = string;
export type shiftType_2 = string;
export type shiftType_3 = string;
export type shiftType_4 = string;
export type shiftType_5 = string;
export type shiftType_6 = string;
export interface condition {
    kind: ASTKinds.condition;
    condType: conditionType;
    updateStatusReg: Nullable<string>;
}
export type conditionType = conditionType_1 | conditionType_2 | conditionType_3 | conditionType_4 | conditionType_5 | conditionType_6 | conditionType_7 | conditionType_8 | conditionType_9 | conditionType_10 | conditionType_11 | conditionType_12 | conditionType_13 | conditionType_14 | conditionType_15 | conditionType_16 | conditionType_17 | conditionType_18 | conditionType_19;
export type conditionType_1 = string;
export type conditionType_2 = string;
export type conditionType_3 = string;
export type conditionType_4 = string;
export type conditionType_5 = string;
export type conditionType_6 = string;
export type conditionType_7 = string;
export type conditionType_8 = string;
export type conditionType_9 = string;
export type conditionType_10 = string;
export type conditionType_11 = string;
export type conditionType_12 = string;
export type conditionType_13 = string;
export type conditionType_14 = string;
export type conditionType_15 = string;
export type conditionType_16 = string;
export type conditionType_17 = string;
export type conditionType_18 = string;
export type conditionType_19 = string;
export type ws = string;
export type wso = string;
export type nend = nend_1 | nend_2;
export type nend_1 = string;
export type nend_2 = {kind: ASTKinds.$EOF};
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating: boolean = false;
    private memoSafe: boolean = true;
    constructor(input: string) {
        this.pos = {overallPos: 0, line: 1, offset: 0};
        this.input = input;
    }
    public reset(pos: PosInfo) {
        this.pos = pos;
    }
    public finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    public clearMemos(): void {
    }
    public matchstart($$dpth: number, $$cr?: ErrorTracker): Nullable<start> {
        return this.run<start>($$dpth,
            () => {
                let $scope$start: Nullable<line>;
                let $$res: Nullable<start> = null;
                if (true
                    && ($scope$start = this.matchline($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.start, start: $scope$start};
                }
                return $$res;
            });
    }
    public matchline($$dpth: number, $$cr?: ErrorTracker): Nullable<line> {
        return this.choice<line>([
            () => this.matchline_1($$dpth + 1, $$cr),
            () => this.matchline_2($$dpth + 1, $$cr),
            () => this.matchline_3($$dpth + 1, $$cr),
            () => this.matchline_4($$dpth + 1, $$cr),
            () => this.matchline_5($$dpth + 1, $$cr),
        ]);
    }
    public matchline_1($$dpth: number, $$cr?: ErrorTracker): Nullable<line_1> {
        return this.run<line_1>($$dpth,
            () => {
                let $scope$label: Nullable<Nullable<label>>;
                let $scope$currentLine: Nullable<directive>;
                let $scope$comment: Nullable<Nullable<comment>>;
                let $scope$nextLine: Nullable<line>;
                let $$res: Nullable<line_1> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[\s]*)`, $$dpth + 1, $$cr) !== null
                    && (($scope$label = this.matchlabel($$dpth + 1, $$cr)) || true)
                    && this.regexAccept(String.raw`(?:[\s]*)`, $$dpth + 1, $$cr) !== null
                    && ($scope$currentLine = this.matchdirective($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && (($scope$comment = this.matchcomment($$dpth + 1, $$cr)) || true)
                    && this.matchnend($$dpth + 1, $$cr) !== null
                    && ($scope$nextLine = this.matchline($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.line_1, label: $scope$label, currentLine: $scope$currentLine, comment: $scope$comment, nextLine: $scope$nextLine};
                }
                return $$res;
            });
    }
    public matchline_2($$dpth: number, $$cr?: ErrorTracker): Nullable<line_2> {
        return this.run<line_2>($$dpth,
            () => {
                let $scope$label: Nullable<Nullable<label>>;
                let $scope$currentLine: Nullable<instruction>;
                let $scope$comment: Nullable<Nullable<comment>>;
                let $scope$nextLine: Nullable<line>;
                let $$res: Nullable<line_2> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[\s]*)`, $$dpth + 1, $$cr) !== null
                    && (($scope$label = this.matchlabel($$dpth + 1, $$cr)) || true)
                    && this.regexAccept(String.raw`(?:[\s]*)`, $$dpth + 1, $$cr) !== null
                    && ($scope$currentLine = this.matchinstruction($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && (($scope$comment = this.matchcomment($$dpth + 1, $$cr)) || true)
                    && this.matchnend($$dpth + 1, $$cr) !== null
                    && ($scope$nextLine = this.matchline($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.line_2, label: $scope$label, currentLine: $scope$currentLine, comment: $scope$comment, nextLine: $scope$nextLine};
                }
                return $$res;
            });
    }
    public matchline_3($$dpth: number, $$cr?: ErrorTracker): Nullable<line_3> {
        return this.run<line_3>($$dpth,
            () => {
                let $scope$label: Nullable<Nullable<label>>;
                let $scope$currentLine: Nullable<variableLine>;
                let $scope$nextLine: Nullable<line>;
                let $$res: Nullable<line_3> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[\s]*)`, $$dpth + 1, $$cr) !== null
                    && (($scope$label = this.matchlabel($$dpth + 1, $$cr)) || true)
                    && this.regexAccept(String.raw`(?:[\s]*)`, $$dpth + 1, $$cr) !== null
                    && ($scope$currentLine = this.matchvariableLine($$dpth + 1, $$cr)) !== null
                    && this.matchnend($$dpth + 1, $$cr) !== null
                    && ($scope$nextLine = this.matchline($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.line_3, label: $scope$label, currentLine: $scope$currentLine, nextLine: $scope$nextLine};
                }
                return $$res;
            });
    }
    public matchline_4($$dpth: number, $$cr?: ErrorTracker): Nullable<line_4> {
        return this.run<line_4>($$dpth,
            () => {
                let $scope$label: Nullable<Nullable<label>>;
                let $scope$currentLine: Nullable<commentLine>;
                let $scope$nextLine: Nullable<line>;
                let $$res: Nullable<line_4> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[\s]*)`, $$dpth + 1, $$cr) !== null
                    && (($scope$label = this.matchlabel($$dpth + 1, $$cr)) || true)
                    && this.regexAccept(String.raw`(?:[\s]*)`, $$dpth + 1, $$cr) !== null
                    && ($scope$currentLine = this.matchcommentLine($$dpth + 1, $$cr)) !== null
                    && this.matchnend($$dpth + 1, $$cr) !== null
                    && ($scope$nextLine = this.matchline($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.line_4, label: $scope$label, currentLine: $scope$currentLine, nextLine: $scope$nextLine};
                }
                return $$res;
            });
    }
    public matchline_5($$dpth: number, $$cr?: ErrorTracker): Nullable<line_5> {
        return this.run<line_5>($$dpth,
            () => {
                let $$res: Nullable<line_5> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[\s]*)`, $$dpth + 1, $$cr) !== null
                    && this.match$EOF($$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.line_5, };
                }
                return $$res;
            });
    }
    public matchdirective($$dpth: number, $$cr?: ErrorTracker): Nullable<directive> {
        return this.choice<directive>([
            () => this.matchdirective_1($$dpth + 1, $$cr),
            () => this.matchdirective_2($$dpth + 1, $$cr),
            () => this.matchdirective_3($$dpth + 1, $$cr),
            () => this.matchdirective_4($$dpth + 1, $$cr),
            () => this.matchdirective_5($$dpth + 1, $$cr),
            () => this.matchdirective_6($$dpth + 1, $$cr),
            () => this.matchdirective_7($$dpth + 1, $$cr),
        ]);
    }
    public matchdirective_1($$dpth: number, $$cr?: ErrorTracker): Nullable<directive_1> {
        return this.run<directive_1>($$dpth,
            () => {
                let $scope$directive: Nullable<ascii>;
                let $$res: Nullable<directive_1> = null;
                if (true
                    && ($scope$directive = this.matchascii($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.directive_1, directive: $scope$directive};
                }
                return $$res;
            });
    }
    public matchdirective_2($$dpth: number, $$cr?: ErrorTracker): Nullable<directive_2> {
        return this.run<directive_2>($$dpth,
            () => {
                let $scope$directive: Nullable<space>;
                let $$res: Nullable<directive_2> = null;
                if (true
                    && ($scope$directive = this.matchspace($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.directive_2, directive: $scope$directive};
                }
                return $$res;
            });
    }
    public matchdirective_3($$dpth: number, $$cr?: ErrorTracker): Nullable<directive_3> {
        return this.run<directive_3>($$dpth,
            () => {
                let $scope$directive: Nullable<string>;
                let $$res: Nullable<directive_3> = null;
                if (true
                    && ($scope$directive = this.regexAccept(String.raw`(?:.[aA][rR][mM])`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.directive_3, directive: $scope$directive};
                }
                return $$res;
            });
    }
    public matchdirective_4($$dpth: number, $$cr?: ErrorTracker): Nullable<directive_4> {
        return this.run<directive_4>($$dpth,
            () => {
                let $scope$directive: Nullable<string>;
                let $$res: Nullable<directive_4> = null;
                if (true
                    && ($scope$directive = this.regexAccept(String.raw`(?:.[tT][eE][xX][tT])`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.directive_4, directive: $scope$directive};
                }
                return $$res;
            });
    }
    public matchdirective_5($$dpth: number, $$cr?: ErrorTracker): Nullable<directive_5> {
        return this.run<directive_5>($$dpth,
            () => {
                let $scope$directive: Nullable<string>;
                let $$res: Nullable<directive_5> = null;
                if (true
                    && ($scope$directive = this.regexAccept(String.raw`(?:.[dD][aA][tT][aA])`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.directive_5, directive: $scope$directive};
                }
                return $$res;
            });
    }
    public matchdirective_6($$dpth: number, $$cr?: ErrorTracker): Nullable<directive_6> {
        return this.run<directive_6>($$dpth,
            () => {
                let $scope$directive: Nullable<string>;
                let $$res: Nullable<directive_6> = null;
                if (true
                    && ($scope$directive = this.regexAccept(String.raw`(?:.[aA][lL][iI][gG][nN])`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.directive_6, directive: $scope$directive};
                }
                return $$res;
            });
    }
    public matchdirective_7($$dpth: number, $$cr?: ErrorTracker): Nullable<directive_7> {
        return this.run<directive_7>($$dpth,
            () => {
                let $scope$directive: Nullable<string>;
                let $$res: Nullable<directive_7> = null;
                if (true
                    && ($scope$directive = this.regexAccept(String.raw`(?:.[gG][lL][oO][bB][aA][lL])`, $$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:_[sS][tT][aA][rR][tT])`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.directive_7, directive: $scope$directive};
                }
                return $$res;
            });
    }
    public matchascii($$dpth: number, $$cr?: ErrorTracker): Nullable<ascii> {
        return this.run<ascii>($$dpth,
            () => {
                let $scope$data: Nullable<string>;
                let $$res: Nullable<ascii> = null;
                if (true
                    && this.regexAccept(String.raw`(?:.[aA][sS][cC][iI][iI])`, $$dpth + 1, $$cr) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:")`, $$dpth + 1, $$cr) !== null
                    && ($scope$data = this.regexAccept(String.raw`(?:[ -!#-~]*)`, $$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:")`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.ascii, data: $scope$data};
                }
                return $$res;
            });
    }
    public matchspace($$dpth: number, $$cr?: ErrorTracker): Nullable<space> {
        return this.run<space>($$dpth,
            () => {
                let $scope$size: Nullable<string>;
                let $$res: Nullable<space> = null;
                if (true
                    && this.regexAccept(String.raw`(?:.[sS][pP][aA][cC][eE])`, $$dpth + 1, $$cr) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$size = this.regexAccept(String.raw`(?:[0-9]+)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.space, size: $scope$size};
                }
                return $$res;
            });
    }
    public matchinstruction($$dpth: number, $$cr?: ErrorTracker): Nullable<instruction> {
        return this.choice<instruction>([
            () => this.matchinstruction_1($$dpth + 1, $$cr),
            () => this.matchinstruction_2($$dpth + 1, $$cr),
            () => this.matchinstruction_3($$dpth + 1, $$cr),
            () => this.matchinstruction_4($$dpth + 1, $$cr),
            () => this.matchinstruction_5($$dpth + 1, $$cr),
            () => this.matchinstruction_6($$dpth + 1, $$cr),
        ]);
    }
    public matchinstruction_1($$dpth: number, $$cr?: ErrorTracker): Nullable<instruction_1> {
        return this.run<instruction_1>($$dpth,
            () => {
                let $scope$instruction: Nullable<art>;
                let $$res: Nullable<instruction_1> = null;
                if (true
                    && ($scope$instruction = this.matchart($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.instruction_1, instruction: $scope$instruction};
                }
                return $$res;
            });
    }
    public matchinstruction_2($$dpth: number, $$cr?: ErrorTracker): Nullable<instruction_2> {
        return this.run<instruction_2>($$dpth,
            () => {
                let $scope$instruction: Nullable<log>;
                let $$res: Nullable<instruction_2> = null;
                if (true
                    && ($scope$instruction = this.matchlog($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.instruction_2, instruction: $scope$instruction};
                }
                return $$res;
            });
    }
    public matchinstruction_3($$dpth: number, $$cr?: ErrorTracker): Nullable<instruction_3> {
        return this.run<instruction_3>($$dpth,
            () => {
                let $scope$instruction: Nullable<copyJump>;
                let $$res: Nullable<instruction_3> = null;
                if (true
                    && ($scope$instruction = this.matchcopyJump($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.instruction_3, instruction: $scope$instruction};
                }
                return $$res;
            });
    }
    public matchinstruction_4($$dpth: number, $$cr?: ErrorTracker): Nullable<instruction_4> {
        return this.run<instruction_4>($$dpth,
            () => {
                let $scope$instruction: Nullable<loadStore>;
                let $$res: Nullable<instruction_4> = null;
                if (true
                    && ($scope$instruction = this.matchloadStore($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.instruction_4, instruction: $scope$instruction};
                }
                return $$res;
            });
    }
    public matchinstruction_5($$dpth: number, $$cr?: ErrorTracker): Nullable<instruction_5> {
        return this.run<instruction_5>($$dpth,
            () => {
                let $scope$instruction: Nullable<loadStoreMultiple>;
                let $$res: Nullable<instruction_5> = null;
                if (true
                    && ($scope$instruction = this.matchloadStoreMultiple($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.instruction_5, instruction: $scope$instruction};
                }
                return $$res;
            });
    }
    public matchinstruction_6($$dpth: number, $$cr?: ErrorTracker): Nullable<instruction_6> {
        return this.run<instruction_6>($$dpth,
            () => {
                let $scope$instruction: Nullable<softwareInterrupt>;
                let $$res: Nullable<instruction_6> = null;
                if (true
                    && ($scope$instruction = this.matchsoftwareInterrupt($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.instruction_6, instruction: $scope$instruction};
                }
                return $$res;
            });
    }
    public matchvariableLine($$dpth: number, $$cr?: ErrorTracker): Nullable<variableLine> {
        return this.run<variableLine>($$dpth,
            () => {
                let $scope$variable: Nullable<string>;
                let $scope$label: Nullable<string>;
                let $$res: Nullable<variableLine> = null;
                if (true
                    && ($scope$variable = this.regexAccept(String.raw`(?:[_A-Za-z][_A-Za-z0-9]*)`, $$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:=)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:.)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:-)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$label = this.regexAccept(String.raw`(?:[_A-Za-z][_A-Za-z0-9]*)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.variableLine, variable: $scope$variable, label: $scope$label};
                }
                return $$res;
            });
    }
    public matchcommentLine($$dpth: number, $$cr?: ErrorTracker): Nullable<commentLine> {
        return this.run<commentLine>($$dpth,
            () => {
                let $scope$commentLine: Nullable<comment>;
                let $$res: Nullable<commentLine> = null;
                if (true
                    && ($scope$commentLine = this.matchcomment($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.commentLine, commentLine: $scope$commentLine};
                }
                return $$res;
            });
    }
    public matchlabel($$dpth: number, $$cr?: ErrorTracker): Nullable<label> {
        return this.run<label>($$dpth,
            () => {
                let $scope$label: Nullable<string>;
                let $$res: Nullable<label> = null;
                if (true
                    && ($scope$label = this.regexAccept(String.raw`(?:[_A-Za-z][_A-Za-z0-9]*)`, $$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?::)`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.label, label: $scope$label};
                }
                return $$res;
            });
    }
    public matchcomment($$dpth: number, $$cr?: ErrorTracker): Nullable<comment> {
        return this.choice<comment>([
            () => this.matchcomment_1($$dpth + 1, $$cr),
            () => this.matchcomment_2($$dpth + 1, $$cr),
        ]);
    }
    public matchcomment_1($$dpth: number, $$cr?: ErrorTracker): Nullable<comment_1> {
        return this.run<comment_1>($$dpth,
            () => {
                let $scope$comment: Nullable<string>;
                let $$res: Nullable<comment_1> = null;
                if (true
                    && ($scope$comment = this.regexAccept(String.raw`(?://[ \t\S]*)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.comment_1, comment: $scope$comment};
                }
                return $$res;
            });
    }
    public matchcomment_2($$dpth: number, $$cr?: ErrorTracker): Nullable<comment_2> {
        return this.run<comment_2>($$dpth,
            () => {
                let $scope$comment: Nullable<string>;
                let $$res: Nullable<comment_2> = null;
                if (true
                    && ($scope$comment = this.regexAccept(String.raw`(?:\/\*[\s -.0-~öäüß]*\*\/)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.comment_2, comment: $scope$comment};
                }
                return $$res;
            });
    }
    public matchart($$dpth: number, $$cr?: ErrorTracker): Nullable<art> {
        return this.choice<art>([
            () => this.matchart_1($$dpth + 1, $$cr),
            () => this.matchart_2($$dpth + 1, $$cr),
            () => this.matchart_3($$dpth + 1, $$cr),
        ]);
    }
    public matchart_1($$dpth: number, $$cr?: ErrorTracker): Nullable<art_1> {
        return this.run<art_1>($$dpth,
            () => {
                let $scope$inst: Nullable<artInst>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<artOp>;
                let $$res: Nullable<art_1> = null;
                if (true
                    && ($scope$inst = this.matchartInst($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchartOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.art_1, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchart_2($$dpth: number, $$cr?: ErrorTracker): Nullable<art_2> {
        return this.run<art_2>($$dpth,
            () => {
                let $scope$inst: Nullable<string>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<artMulOp>;
                let $$res: Nullable<art_2> = null;
                if (true
                    && ($scope$inst = this.regexAccept(String.raw`(?:[mM][uU][lL])`, $$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchartMulOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.art_2, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchart_3($$dpth: number, $$cr?: ErrorTracker): Nullable<art_3> {
        return this.run<art_3>($$dpth,
            () => {
                let $scope$inst: Nullable<string>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<artMlaOp>;
                let $$res: Nullable<art_3> = null;
                if (true
                    && ($scope$inst = this.regexAccept(String.raw`(?:[mM][lL][aA])`, $$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchartMlaOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.art_3, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchartInst($$dpth: number, $$cr?: ErrorTracker): Nullable<artInst> {
        return this.choice<artInst>([
            () => this.matchartInst_1($$dpth + 1, $$cr),
            () => this.matchartInst_2($$dpth + 1, $$cr),
            () => this.matchartInst_3($$dpth + 1, $$cr),
            () => this.matchartInst_4($$dpth + 1, $$cr),
            () => this.matchartInst_5($$dpth + 1, $$cr),
            () => this.matchartInst_6($$dpth + 1, $$cr),
        ]);
    }
    public matchartInst_1($$dpth: number, $$cr?: ErrorTracker): Nullable<artInst_1> {
        return this.regexAccept(String.raw`(?:[aA][dD][dD])`, $$dpth + 1, $$cr);
    }
    public matchartInst_2($$dpth: number, $$cr?: ErrorTracker): Nullable<artInst_2> {
        return this.regexAccept(String.raw`(?:[aA][dD][cC])`, $$dpth + 1, $$cr);
    }
    public matchartInst_3($$dpth: number, $$cr?: ErrorTracker): Nullable<artInst_3> {
        return this.regexAccept(String.raw`(?:[sS][uU][bB])`, $$dpth + 1, $$cr);
    }
    public matchartInst_4($$dpth: number, $$cr?: ErrorTracker): Nullable<artInst_4> {
        return this.regexAccept(String.raw`(?:[sS][bB][cC])`, $$dpth + 1, $$cr);
    }
    public matchartInst_5($$dpth: number, $$cr?: ErrorTracker): Nullable<artInst_5> {
        return this.regexAccept(String.raw`(?:[rR][sS][bB])`, $$dpth + 1, $$cr);
    }
    public matchartInst_6($$dpth: number, $$cr?: ErrorTracker): Nullable<artInst_6> {
        return this.regexAccept(String.raw`(?:[rR][sS][cC])`, $$dpth + 1, $$cr);
    }
    public matchartOp($$dpth: number, $$cr?: ErrorTracker): Nullable<artOp> {
        return this.choice<artOp>([
            () => this.matchartOp_1($$dpth + 1, $$cr),
            () => this.matchartOp_2($$dpth + 1, $$cr),
        ]);
    }
    public matchartOp_1($$dpth: number, $$cr?: ErrorTracker): Nullable<artOp_1> {
        return this.matchartOp3($$dpth + 1, $$cr);
    }
    public matchartOp_2($$dpth: number, $$cr?: ErrorTracker): Nullable<artOp_2> {
        return this.matchartOp2($$dpth + 1, $$cr);
    }
    public matchartOp2($$dpth: number, $$cr?: ErrorTracker): Nullable<artOp2> {
        return this.run<artOp2>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<op>;
                let $$res: Nullable<artOp2> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchop($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.artOp2, op1: $scope$op1, op2: $scope$op2};
                }
                return $$res;
            });
    }
    public matchartOp3($$dpth: number, $$cr?: ErrorTracker): Nullable<artOp3> {
        return this.run<artOp3>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<regOp>;
                let $scope$op3: Nullable<op>;
                let $$res: Nullable<artOp3> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op3 = this.matchop($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.artOp3, op1: $scope$op1, op2: $scope$op2, op3: $scope$op3};
                }
                return $$res;
            });
    }
    public matchartMulOp($$dpth: number, $$cr?: ErrorTracker): Nullable<artMulOp> {
        return this.run<artMulOp>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<regOp>;
                let $scope$op3: Nullable<regOp>;
                let $$res: Nullable<artMulOp> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op3 = this.matchregOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.artMulOp, op1: $scope$op1, op2: $scope$op2, op3: $scope$op3};
                }
                return $$res;
            });
    }
    public matchartMlaOp($$dpth: number, $$cr?: ErrorTracker): Nullable<artMlaOp> {
        return this.run<artMlaOp>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<regOp>;
                let $scope$op3: Nullable<regOp>;
                let $scope$op4: Nullable<regOp>;
                let $$res: Nullable<artMlaOp> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op3 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op4 = this.matchregOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.artMlaOp, op1: $scope$op1, op2: $scope$op2, op3: $scope$op3, op4: $scope$op4};
                }
                return $$res;
            });
    }
    public matchlog($$dpth: number, $$cr?: ErrorTracker): Nullable<log> {
        return this.choice<log>([
            () => this.matchlog_1($$dpth + 1, $$cr),
            () => this.matchlog_2($$dpth + 1, $$cr),
        ]);
    }
    public matchlog_1($$dpth: number, $$cr?: ErrorTracker): Nullable<log_1> {
        return this.run<log_1>($$dpth,
            () => {
                let $scope$inst: Nullable<logInst>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<logOp>;
                let $$res: Nullable<log_1> = null;
                if (true
                    && ($scope$inst = this.matchlogInst($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchlogOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.log_1, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchlog_2($$dpth: number, $$cr?: ErrorTracker): Nullable<log_2> {
        return this.run<log_2>($$dpth,
            () => {
                let $scope$inst: Nullable<logCmpInst>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<logOp2>;
                let $$res: Nullable<log_2> = null;
                if (true
                    && ($scope$inst = this.matchlogCmpInst($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchlogOp2($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.log_2, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchlogInst($$dpth: number, $$cr?: ErrorTracker): Nullable<logInst> {
        return this.choice<logInst>([
            () => this.matchlogInst_1($$dpth + 1, $$cr),
            () => this.matchlogInst_2($$dpth + 1, $$cr),
            () => this.matchlogInst_3($$dpth + 1, $$cr),
            () => this.matchlogInst_4($$dpth + 1, $$cr),
        ]);
    }
    public matchlogInst_1($$dpth: number, $$cr?: ErrorTracker): Nullable<logInst_1> {
        return this.regexAccept(String.raw`(?:[aA][nN][dD])`, $$dpth + 1, $$cr);
    }
    public matchlogInst_2($$dpth: number, $$cr?: ErrorTracker): Nullable<logInst_2> {
        return this.regexAccept(String.raw`(?:[oO][rR][rR])`, $$dpth + 1, $$cr);
    }
    public matchlogInst_3($$dpth: number, $$cr?: ErrorTracker): Nullable<logInst_3> {
        return this.regexAccept(String.raw`(?:[eE][oO][rR])`, $$dpth + 1, $$cr);
    }
    public matchlogInst_4($$dpth: number, $$cr?: ErrorTracker): Nullable<logInst_4> {
        return this.regexAccept(String.raw`(?:[bB][iI][cC])`, $$dpth + 1, $$cr);
    }
    public matchlogCmpInst($$dpth: number, $$cr?: ErrorTracker): Nullable<logCmpInst> {
        return this.choice<logCmpInst>([
            () => this.matchlogCmpInst_1($$dpth + 1, $$cr),
            () => this.matchlogCmpInst_2($$dpth + 1, $$cr),
            () => this.matchlogCmpInst_3($$dpth + 1, $$cr),
            () => this.matchlogCmpInst_4($$dpth + 1, $$cr),
        ]);
    }
    public matchlogCmpInst_1($$dpth: number, $$cr?: ErrorTracker): Nullable<logCmpInst_1> {
        return this.regexAccept(String.raw`(?:[cC][mM][pP])`, $$dpth + 1, $$cr);
    }
    public matchlogCmpInst_2($$dpth: number, $$cr?: ErrorTracker): Nullable<logCmpInst_2> {
        return this.regexAccept(String.raw`(?:[cC][mM][nN])`, $$dpth + 1, $$cr);
    }
    public matchlogCmpInst_3($$dpth: number, $$cr?: ErrorTracker): Nullable<logCmpInst_3> {
        return this.regexAccept(String.raw`(?:[tT][sS][tT])`, $$dpth + 1, $$cr);
    }
    public matchlogCmpInst_4($$dpth: number, $$cr?: ErrorTracker): Nullable<logCmpInst_4> {
        return this.regexAccept(String.raw`(?:[tT][eE][qQ])`, $$dpth + 1, $$cr);
    }
    public matchlogOp($$dpth: number, $$cr?: ErrorTracker): Nullable<logOp> {
        return this.choice<logOp>([
            () => this.matchlogOp_1($$dpth + 1, $$cr),
            () => this.matchlogOp_2($$dpth + 1, $$cr),
        ]);
    }
    public matchlogOp_1($$dpth: number, $$cr?: ErrorTracker): Nullable<logOp_1> {
        return this.matchlogOp3($$dpth + 1, $$cr);
    }
    public matchlogOp_2($$dpth: number, $$cr?: ErrorTracker): Nullable<logOp_2> {
        return this.matchlogOp2($$dpth + 1, $$cr);
    }
    public matchlogOp2($$dpth: number, $$cr?: ErrorTracker): Nullable<logOp2> {
        return this.run<logOp2>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<op>;
                let $$res: Nullable<logOp2> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchop($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.logOp2, op1: $scope$op1, op2: $scope$op2};
                }
                return $$res;
            });
    }
    public matchlogOp3($$dpth: number, $$cr?: ErrorTracker): Nullable<logOp3> {
        return this.run<logOp3>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<regOp>;
                let $scope$op3: Nullable<op>;
                let $$res: Nullable<logOp3> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op3 = this.matchop($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.logOp3, op1: $scope$op1, op2: $scope$op2, op3: $scope$op3};
                }
                return $$res;
            });
    }
    public matchcopyJump($$dpth: number, $$cr?: ErrorTracker): Nullable<copyJump> {
        return this.choice<copyJump>([
            () => this.matchcopyJump_1($$dpth + 1, $$cr),
            () => this.matchcopyJump_2($$dpth + 1, $$cr),
            () => this.matchcopyJump_3($$dpth + 1, $$cr),
        ]);
    }
    public matchcopyJump_1($$dpth: number, $$cr?: ErrorTracker): Nullable<copyJump_1> {
        return this.run<copyJump_1>($$dpth,
            () => {
                let $scope$inst: Nullable<copyInst>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<copyOp>;
                let $$res: Nullable<copyJump_1> = null;
                if (true
                    && ($scope$inst = this.matchcopyInst($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchcopyOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.copyJump_1, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchcopyJump_2($$dpth: number, $$cr?: ErrorTracker): Nullable<copyJump_2> {
        return this.run<copyJump_2>($$dpth,
            () => {
                let $scope$inst: Nullable<jumpInst1>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<jumpOp>;
                let $$res: Nullable<copyJump_2> = null;
                if (true
                    && ($scope$inst = this.matchjumpInst1($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchjumpOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.copyJump_2, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchcopyJump_3($$dpth: number, $$cr?: ErrorTracker): Nullable<copyJump_3> {
        return this.run<copyJump_3>($$dpth,
            () => {
                let $scope$inst: Nullable<jumpInst2>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<jumpOp>;
                let $$res: Nullable<copyJump_3> = null;
                if (true
                    && ($scope$inst = this.matchjumpInst2($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchjumpOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.copyJump_3, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchcopyInst($$dpth: number, $$cr?: ErrorTracker): Nullable<copyInst> {
        return this.choice<copyInst>([
            () => this.matchcopyInst_1($$dpth + 1, $$cr),
            () => this.matchcopyInst_2($$dpth + 1, $$cr),
        ]);
    }
    public matchcopyInst_1($$dpth: number, $$cr?: ErrorTracker): Nullable<copyInst_1> {
        return this.regexAccept(String.raw`(?:[mM][oO][vV])`, $$dpth + 1, $$cr);
    }
    public matchcopyInst_2($$dpth: number, $$cr?: ErrorTracker): Nullable<copyInst_2> {
        return this.regexAccept(String.raw`(?:[mM][vV][nN])`, $$dpth + 1, $$cr);
    }
    public matchjumpInst1($$dpth: number, $$cr?: ErrorTracker): Nullable<jumpInst1> {
        return this.regexAccept(String.raw`(?:[bB])`, $$dpth + 1, $$cr);
    }
    public matchjumpInst2($$dpth: number, $$cr?: ErrorTracker): Nullable<jumpInst2> {
        return this.regexAccept(String.raw`(?:[bB][lL])`, $$dpth + 1, $$cr);
    }
    public matchcopyOp($$dpth: number, $$cr?: ErrorTracker): Nullable<copyOp> {
        return this.run<copyOp>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<op>;
                let $$res: Nullable<copyOp> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchop($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.copyOp, op1: $scope$op1, op2: $scope$op2};
                }
                return $$res;
            });
    }
    public matchjumpOp($$dpth: number, $$cr?: ErrorTracker): Nullable<jumpOp> {
        return this.run<jumpOp>($$dpth,
            () => {
                let $scope$op1: Nullable<branchOp>;
                let $$res: Nullable<jumpOp> = null;
                if (true
                    && ($scope$op1 = this.matchbranchOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.jumpOp, op1: $scope$op1};
                }
                return $$res;
            });
    }
    public matchloadStore($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStore> {
        return this.choice<loadStore>([
            () => this.matchloadStore_1($$dpth + 1, $$cr),
            () => this.matchloadStore_2($$dpth + 1, $$cr),
            () => this.matchloadStore_3($$dpth + 1, $$cr),
            () => this.matchloadStore_4($$dpth + 1, $$cr),
        ]);
    }
    public matchloadStore_1($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStore_1> {
        return this.run<loadStore_1>($$dpth,
            () => {
                let $scope$inst: Nullable<loadStoreInst>;
                let $scope$format: Nullable<format>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<loadStoreOp>;
                let $$res: Nullable<loadStore_1> = null;
                if (true
                    && ($scope$inst = this.matchloadStoreInst($$dpth + 1, $$cr)) !== null
                    && ($scope$format = this.matchformat($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchloadStoreOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.loadStore_1, inst: $scope$inst, format: $scope$format, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchloadStore_2($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStore_2> {
        return this.run<loadStore_2>($$dpth,
            () => {
                let $scope$inst: Nullable<string>;
                let $scope$format: Nullable<format>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<swpOp>;
                let $$res: Nullable<loadStore_2> = null;
                if (true
                    && ($scope$inst = this.regexAccept(String.raw`(?:[sS][wW][pP])`, $$dpth + 1, $$cr)) !== null
                    && ($scope$format = this.matchformat($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchswpOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.loadStore_2, inst: $scope$inst, format: $scope$format, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchloadStore_3($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStore_3> {
        return this.run<loadStore_3>($$dpth,
            () => {
                let $scope$inst: Nullable<loadStoreInst>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<loadImmediateBranchOp>;
                let $$res: Nullable<loadStore_3> = null;
                if (true
                    && ($scope$inst = this.matchloadStoreInst($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchloadImmediateBranchOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.loadStore_3, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchloadStore_4($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStore_4> {
        return this.run<loadStore_4>($$dpth,
            () => {
                let $scope$inst: Nullable<loadStoreInst>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<loadImmediateOp>;
                let $$res: Nullable<loadStore_4> = null;
                if (true
                    && ($scope$inst = this.matchloadStoreInst($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchloadImmediateOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.loadStore_4, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchloadStoreInst($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStoreInst> {
        return this.choice<loadStoreInst>([
            () => this.matchloadStoreInst_1($$dpth + 1, $$cr),
            () => this.matchloadStoreInst_2($$dpth + 1, $$cr),
        ]);
    }
    public matchloadStoreInst_1($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStoreInst_1> {
        return this.regexAccept(String.raw`(?:[lL][dD][rR])`, $$dpth + 1, $$cr);
    }
    public matchloadStoreInst_2($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStoreInst_2> {
        return this.regexAccept(String.raw`(?:[sS][tT][rR])`, $$dpth + 1, $$cr);
    }
    public matchformat($$dpth: number, $$cr?: ErrorTracker): Nullable<format> {
        return this.choice<format>([
            () => this.matchformat_1($$dpth + 1, $$cr),
            () => this.matchformat_2($$dpth + 1, $$cr),
            () => this.matchformat_3($$dpth + 1, $$cr),
            () => this.matchformat_4($$dpth + 1, $$cr),
            () => this.matchformat_5($$dpth + 1, $$cr),
        ]);
    }
    public matchformat_1($$dpth: number, $$cr?: ErrorTracker): Nullable<format_1> {
        return this.regexAccept(String.raw`(?:[bB])`, $$dpth + 1, $$cr);
    }
    public matchformat_2($$dpth: number, $$cr?: ErrorTracker): Nullable<format_2> {
        return this.regexAccept(String.raw`(?:[hH])`, $$dpth + 1, $$cr);
    }
    public matchformat_3($$dpth: number, $$cr?: ErrorTracker): Nullable<format_3> {
        return this.regexAccept(String.raw`(?:[sS][bB])`, $$dpth + 1, $$cr);
    }
    public matchformat_4($$dpth: number, $$cr?: ErrorTracker): Nullable<format_4> {
        return this.regexAccept(String.raw`(?:[sS][hH])`, $$dpth + 1, $$cr);
    }
    public matchformat_5($$dpth: number, $$cr?: ErrorTracker): Nullable<format_5> {
        return this.regexAccept(String.raw`(?:)`, $$dpth + 1, $$cr);
    }
    public matchloadStoreOp($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStoreOp> {
        return this.run<loadStoreOp>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<addressingMode>;
                let $$res: Nullable<loadStoreOp> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchaddressingMode($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.loadStoreOp, op1: $scope$op1, op2: $scope$op2};
                }
                return $$res;
            });
    }
    public matchswpOp($$dpth: number, $$cr?: ErrorTracker): Nullable<swpOp> {
        return this.run<swpOp>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<regOp>;
                let $scope$op3: Nullable<regOp>;
                let $$res: Nullable<swpOp> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\[)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op3 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\])`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.swpOp, op1: $scope$op1, op2: $scope$op2, op3: $scope$op3};
                }
                return $$res;
            });
    }
    public matchloadImmediateOp($$dpth: number, $$cr?: ErrorTracker): Nullable<loadImmediateOp> {
        return this.run<loadImmediateOp>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<immOp>;
                let $$res: Nullable<loadImmediateOp> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchimmOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.loadImmediateOp, op1: $scope$op1, op2: $scope$op2};
                }
                return $$res;
            });
    }
    public matchloadImmediateBranchOp($$dpth: number, $$cr?: ErrorTracker): Nullable<loadImmediateBranchOp> {
        return this.run<loadImmediateBranchOp>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<branchOp>;
                let $scope$offset: Nullable<Nullable<string>>;
                let $$res: Nullable<loadImmediateBranchOp> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:=)`, $$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchbranchOp($$dpth + 1, $$cr)) !== null
                    && (($scope$offset = this.regexAccept(String.raw`(?:[+-][0-9]+)`, $$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.loadImmediateBranchOp, op1: $scope$op1, op2: $scope$op2, offset: $scope$offset};
                }
                return $$res;
            });
    }
    public matchloadStoreMultiple($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStoreMultiple> {
        return this.run<loadStoreMultiple>($$dpth,
            () => {
                let $scope$inst: Nullable<loadStoreMultipleInst>;
                let $scope$addressingMode: Nullable<loadStoreMultipleAddrMode>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<loadStoreMultipleOp>;
                let $$res: Nullable<loadStoreMultiple> = null;
                if (true
                    && ($scope$inst = this.matchloadStoreMultipleInst($$dpth + 1, $$cr)) !== null
                    && ($scope$addressingMode = this.matchloadStoreMultipleAddrMode($$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.matchloadStoreMultipleOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.loadStoreMultiple, inst: $scope$inst, addressingMode: $scope$addressingMode, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchloadStoreMultipleInst($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStoreMultipleInst> {
        return this.choice<loadStoreMultipleInst>([
            () => this.matchloadStoreMultipleInst_1($$dpth + 1, $$cr),
            () => this.matchloadStoreMultipleInst_2($$dpth + 1, $$cr),
        ]);
    }
    public matchloadStoreMultipleInst_1($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStoreMultipleInst_1> {
        return this.regexAccept(String.raw`(?:[lL][dD][mM])`, $$dpth + 1, $$cr);
    }
    public matchloadStoreMultipleInst_2($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStoreMultipleInst_2> {
        return this.regexAccept(String.raw`(?:[sS][tT][mM])`, $$dpth + 1, $$cr);
    }
    public matchloadStoreMultipleAddrMode($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStoreMultipleAddrMode> {
        return this.choice<loadStoreMultipleAddrMode>([
            () => this.matchloadStoreMultipleAddrMode_1($$dpth + 1, $$cr),
            () => this.matchloadStoreMultipleAddrMode_2($$dpth + 1, $$cr),
            () => this.matchloadStoreMultipleAddrMode_3($$dpth + 1, $$cr),
            () => this.matchloadStoreMultipleAddrMode_4($$dpth + 1, $$cr),
            () => this.matchloadStoreMultipleAddrMode_5($$dpth + 1, $$cr),
            () => this.matchloadStoreMultipleAddrMode_6($$dpth + 1, $$cr),
            () => this.matchloadStoreMultipleAddrMode_7($$dpth + 1, $$cr),
            () => this.matchloadStoreMultipleAddrMode_8($$dpth + 1, $$cr),
            () => this.matchloadStoreMultipleAddrMode_9($$dpth + 1, $$cr),
        ]);
    }
    public matchloadStoreMultipleAddrMode_1($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStoreMultipleAddrMode_1> {
        return this.regexAccept(String.raw`(?:[fF][dD])`, $$dpth + 1, $$cr);
    }
    public matchloadStoreMultipleAddrMode_2($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStoreMultipleAddrMode_2> {
        return this.regexAccept(String.raw`(?:[fF][aA])`, $$dpth + 1, $$cr);
    }
    public matchloadStoreMultipleAddrMode_3($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStoreMultipleAddrMode_3> {
        return this.regexAccept(String.raw`(?:[eE][dD])`, $$dpth + 1, $$cr);
    }
    public matchloadStoreMultipleAddrMode_4($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStoreMultipleAddrMode_4> {
        return this.regexAccept(String.raw`(?:[eE][aA])`, $$dpth + 1, $$cr);
    }
    public matchloadStoreMultipleAddrMode_5($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStoreMultipleAddrMode_5> {
        return this.regexAccept(String.raw`(?:[iI][aA])`, $$dpth + 1, $$cr);
    }
    public matchloadStoreMultipleAddrMode_6($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStoreMultipleAddrMode_6> {
        return this.regexAccept(String.raw`(?:[iI][bB])`, $$dpth + 1, $$cr);
    }
    public matchloadStoreMultipleAddrMode_7($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStoreMultipleAddrMode_7> {
        return this.regexAccept(String.raw`(?:[dD][aA])`, $$dpth + 1, $$cr);
    }
    public matchloadStoreMultipleAddrMode_8($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStoreMultipleAddrMode_8> {
        return this.regexAccept(String.raw`(?:[dD][bB])`, $$dpth + 1, $$cr);
    }
    public matchloadStoreMultipleAddrMode_9($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStoreMultipleAddrMode_9> {
        return this.regexAccept(String.raw`(?:)`, $$dpth + 1, $$cr);
    }
    public matchloadStoreMultipleOp($$dpth: number, $$cr?: ErrorTracker): Nullable<loadStoreMultipleOp> {
        return this.run<loadStoreMultipleOp>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$increment: Nullable<Nullable<string>>;
                let $scope$op2: Nullable<regOpList>;
                let $$res: Nullable<loadStoreMultipleOp> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && (($scope$increment = this.regexAccept(String.raw`(?:!)`, $$dpth + 1, $$cr)) || true)
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:{)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchregOpList($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:})`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.loadStoreMultipleOp, op1: $scope$op1, increment: $scope$increment, op2: $scope$op2};
                }
                return $$res;
            });
    }
    public matchsoftwareInterrupt($$dpth: number, $$cr?: ErrorTracker): Nullable<softwareInterrupt> {
        return this.run<softwareInterrupt>($$dpth,
            () => {
                let $scope$inst: Nullable<string>;
                let $scope$cond: Nullable<condition>;
                let $scope$operands: Nullable<string>;
                let $$res: Nullable<softwareInterrupt> = null;
                if (true
                    && ($scope$inst = this.regexAccept(String.raw`(?:[sS][wW][iI])`, $$dpth + 1, $$cr)) !== null
                    && ($scope$cond = this.matchcondition($$dpth + 1, $$cr)) !== null
                    && this.matchws($$dpth + 1, $$cr) !== null
                    && ($scope$operands = this.regexAccept(String.raw`(?:#0)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.softwareInterrupt, inst: $scope$inst, cond: $scope$cond, operands: $scope$operands};
                }
                return $$res;
            });
    }
    public matchop($$dpth: number, $$cr?: ErrorTracker): Nullable<op> {
        return this.choice<op>([
            () => this.matchop_1($$dpth + 1, $$cr),
            () => this.matchop_2($$dpth + 1, $$cr),
        ]);
    }
    public matchop_1($$dpth: number, $$cr?: ErrorTracker): Nullable<op_1> {
        return this.run<op_1>($$dpth,
            () => {
                let $scope$shiftOp: Nullable<shiftOp>;
                let $$res: Nullable<op_1> = null;
                if (true
                    && ($scope$shiftOp = this.matchshiftOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.op_1, shiftOp: $scope$shiftOp};
                }
                return $$res;
            });
    }
    public matchop_2($$dpth: number, $$cr?: ErrorTracker): Nullable<op_2> {
        return this.run<op_2>($$dpth,
            () => {
                let $scope$regImmOp: Nullable<regImmOp>;
                let $$res: Nullable<op_2> = null;
                if (true
                    && ($scope$regImmOp = this.matchregImmOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.op_2, regImmOp: $scope$regImmOp};
                }
                return $$res;
            });
    }
    public matchregImmOp($$dpth: number, $$cr?: ErrorTracker): Nullable<regImmOp> {
        return this.choice<regImmOp>([
            () => this.matchregImmOp_1($$dpth + 1, $$cr),
            () => this.matchregImmOp_2($$dpth + 1, $$cr),
        ]);
    }
    public matchregImmOp_1($$dpth: number, $$cr?: ErrorTracker): Nullable<regImmOp_1> {
        return this.run<regImmOp_1>($$dpth,
            () => {
                let $scope$regOp: Nullable<regOp>;
                let $$res: Nullable<regImmOp_1> = null;
                if (true
                    && ($scope$regOp = this.matchregOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.regImmOp_1, regOp: $scope$regOp};
                }
                return $$res;
            });
    }
    public matchregImmOp_2($$dpth: number, $$cr?: ErrorTracker): Nullable<regImmOp_2> {
        return this.run<regImmOp_2>($$dpth,
            () => {
                let $scope$immOp: Nullable<immOp>;
                let $$res: Nullable<regImmOp_2> = null;
                if (true
                    && ($scope$immOp = this.matchimmOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.regImmOp_2, immOp: $scope$immOp};
                }
                return $$res;
            });
    }
    public matchshiftOp($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftOp> {
        return this.run<shiftOp>($$dpth,
            () => {
                let $scope$opToShift: Nullable<regImmOp>;
                let $scope$shiftType: Nullable<shiftType>;
                let $scope$opShift: Nullable<regImmOp>;
                let $$res: Nullable<shiftOp> = null;
                if (true
                    && ($scope$opToShift = this.matchregImmOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$shiftType = this.matchshiftType($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$opShift = this.matchregImmOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.shiftOp, opToShift: $scope$opToShift, shiftType: $scope$shiftType, opShift: $scope$opShift};
                }
                return $$res;
            });
    }
    public matchaddressingMode($$dpth: number, $$cr?: ErrorTracker): Nullable<addressingMode> {
        return this.choice<addressingMode>([
            () => this.matchaddressingMode_1($$dpth + 1, $$cr),
            () => this.matchaddressingMode_2($$dpth + 1, $$cr),
        ]);
    }
    public matchaddressingMode_1($$dpth: number, $$cr?: ErrorTracker): Nullable<addressingMode_1> {
        return this.run<addressingMode_1>($$dpth,
            () => {
                let $scope$reg: Nullable<regOp>;
                let $scope$offset: Nullable<Nullable<offset>>;
                let $$res: Nullable<addressingMode_1> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\[)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$reg = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\])`, $$dpth + 1, $$cr) !== null
                    && (($scope$offset = this.matchoffset($$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.addressingMode_1, reg: $scope$reg, offset: $scope$offset};
                }
                return $$res;
            });
    }
    public matchaddressingMode_2($$dpth: number, $$cr?: ErrorTracker): Nullable<addressingMode_2> {
        return this.run<addressingMode_2>($$dpth,
            () => {
                let $scope$reg: Nullable<regOp>;
                let $scope$offset: Nullable<Nullable<offset>>;
                let $scope$increment: Nullable<Nullable<string>>;
                let $$res: Nullable<addressingMode_2> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\[)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$reg = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && (($scope$offset = this.matchoffset($$dpth + 1, $$cr)) || true)
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:\])`, $$dpth + 1, $$cr) !== null
                    && (($scope$increment = this.regexAccept(String.raw`(?:!)`, $$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.addressingMode_2, reg: $scope$reg, offset: $scope$offset, increment: $scope$increment};
                }
                return $$res;
            });
    }
    public matchoffset($$dpth: number, $$cr?: ErrorTracker): Nullable<offset> {
        return this.run<offset>($$dpth,
            () => {
                let $scope$sign: Nullable<sign>;
                let $scope$offset: Nullable<op>;
                let $$res: Nullable<offset> = null;
                if (true
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$sign = this.matchsign($$dpth + 1, $$cr)) !== null
                    && ($scope$offset = this.matchop($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.offset, sign: $scope$sign, offset: $scope$offset};
                }
                return $$res;
            });
    }
    public matchregOp($$dpth: number, $$cr?: ErrorTracker): Nullable<regOp> {
        return this.choice<regOp>([
            () => this.matchregOp_1($$dpth + 1, $$cr),
            () => this.matchregOp_2($$dpth + 1, $$cr),
            () => this.matchregOp_3($$dpth + 1, $$cr),
            () => this.matchregOp_4($$dpth + 1, $$cr),
        ]);
    }
    public matchregOp_1($$dpth: number, $$cr?: ErrorTracker): Nullable<regOp_1> {
        return this.run<regOp_1>($$dpth,
            () => {
                let $scope$regOp: Nullable<string>;
                let $$res: Nullable<regOp_1> = null;
                if (true
                    && ($scope$regOp = this.regexAccept(String.raw`(?:[rR][0-9]+)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.regOp_1, regOp: $scope$regOp};
                }
                return $$res;
            });
    }
    public matchregOp_2($$dpth: number, $$cr?: ErrorTracker): Nullable<regOp_2> {
        return this.regexAccept(String.raw`(?:[pP][cC])`, $$dpth + 1, $$cr);
    }
    public matchregOp_3($$dpth: number, $$cr?: ErrorTracker): Nullable<regOp_3> {
        return this.regexAccept(String.raw`(?:[lL][rR])`, $$dpth + 1, $$cr);
    }
    public matchregOp_4($$dpth: number, $$cr?: ErrorTracker): Nullable<regOp_4> {
        return this.regexAccept(String.raw`(?:[sS][pP])`, $$dpth + 1, $$cr);
    }
    public matchimmOp($$dpth: number, $$cr?: ErrorTracker): Nullable<immOp> {
        return this.run<immOp>($$dpth,
            () => {
                let $scope$immType: Nullable<immType>;
                let $scope$sign: Nullable<sign>;
                let $scope$base: Nullable<base>;
                let $scope$number: Nullable<string>;
                let $$res: Nullable<immOp> = null;
                if (true
                    && ($scope$immType = this.matchimmType($$dpth + 1, $$cr)) !== null
                    && ($scope$sign = this.matchsign($$dpth + 1, $$cr)) !== null
                    && ($scope$base = this.matchbase($$dpth + 1, $$cr)) !== null
                    && ($scope$number = this.regexAccept(String.raw`(?:[0-9a-fA-F]+)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.immOp, immType: $scope$immType, sign: $scope$sign, base: $scope$base, number: $scope$number};
                }
                return $$res;
            });
    }
    public matchimmType($$dpth: number, $$cr?: ErrorTracker): Nullable<immType> {
        return this.choice<immType>([
            () => this.matchimmType_1($$dpth + 1, $$cr),
            () => this.matchimmType_2($$dpth + 1, $$cr),
        ]);
    }
    public matchimmType_1($$dpth: number, $$cr?: ErrorTracker): Nullable<immType_1> {
        return this.regexAccept(String.raw`(?:#)`, $$dpth + 1, $$cr);
    }
    public matchimmType_2($$dpth: number, $$cr?: ErrorTracker): Nullable<immType_2> {
        return this.regexAccept(String.raw`(?:=)`, $$dpth + 1, $$cr);
    }
    public matchbase($$dpth: number, $$cr?: ErrorTracker): Nullable<base> {
        return this.choice<base>([
            () => this.matchbase_1($$dpth + 1, $$cr),
            () => this.matchbase_2($$dpth + 1, $$cr),
            () => this.matchbase_3($$dpth + 1, $$cr),
            () => this.matchbase_4($$dpth + 1, $$cr),
        ]);
    }
    public matchbase_1($$dpth: number, $$cr?: ErrorTracker): Nullable<base_1> {
        return this.regexAccept(String.raw`(?:0[xX])`, $$dpth + 1, $$cr);
    }
    public matchbase_2($$dpth: number, $$cr?: ErrorTracker): Nullable<base_2> {
        return this.regexAccept(String.raw`(?:0[bB])`, $$dpth + 1, $$cr);
    }
    public matchbase_3($$dpth: number, $$cr?: ErrorTracker): Nullable<base_3> {
        return this.regexAccept(String.raw`(?:0[oO])`, $$dpth + 1, $$cr);
    }
    public matchbase_4($$dpth: number, $$cr?: ErrorTracker): Nullable<base_4> {
        return this.regexAccept(String.raw`(?:)`, $$dpth + 1, $$cr);
    }
    public matchsign($$dpth: number, $$cr?: ErrorTracker): Nullable<sign> {
        return this.choice<sign>([
            () => this.matchsign_1($$dpth + 1, $$cr),
            () => this.matchsign_2($$dpth + 1, $$cr),
            () => this.matchsign_3($$dpth + 1, $$cr),
        ]);
    }
    public matchsign_1($$dpth: number, $$cr?: ErrorTracker): Nullable<sign_1> {
        return this.regexAccept(String.raw`(?:-)`, $$dpth + 1, $$cr);
    }
    public matchsign_2($$dpth: number, $$cr?: ErrorTracker): Nullable<sign_2> {
        return this.regexAccept(String.raw`(?:\+)`, $$dpth + 1, $$cr);
    }
    public matchsign_3($$dpth: number, $$cr?: ErrorTracker): Nullable<sign_3> {
        return this.regexAccept(String.raw`(?:)`, $$dpth + 1, $$cr);
    }
    public matchbranchOp($$dpth: number, $$cr?: ErrorTracker): Nullable<branchOp> {
        return this.regexAccept(String.raw`(?:[_A-Za-z][_A-Za-z0-9]*)`, $$dpth + 1, $$cr);
    }
    public matchregOpList($$dpth: number, $$cr?: ErrorTracker): Nullable<regOpList> {
        return this.choice<regOpList>([
            () => this.matchregOpList_1($$dpth + 1, $$cr),
            () => this.matchregOpList_2($$dpth + 1, $$cr),
        ]);
    }
    public matchregOpList_1($$dpth: number, $$cr?: ErrorTracker): Nullable<regOpList_1> {
        return this.run<regOpList_1>($$dpth,
            () => {
                let $scope$op: Nullable<regOpOrRange>;
                let $scope$nextOp: Nullable<regOpList>;
                let $$res: Nullable<regOpList_1> = null;
                if (true
                    && ($scope$op = this.matchregOpOrRange($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$nextOp = this.matchregOpList($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.regOpList_1, op: $scope$op, nextOp: $scope$nextOp};
                }
                return $$res;
            });
    }
    public matchregOpList_2($$dpth: number, $$cr?: ErrorTracker): Nullable<regOpList_2> {
        return this.run<regOpList_2>($$dpth,
            () => {
                let $scope$op: Nullable<regOpOrRange>;
                let $$res: Nullable<regOpList_2> = null;
                if (true
                    && ($scope$op = this.matchregOpOrRange($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.regOpList_2, op: $scope$op};
                }
                return $$res;
            });
    }
    public matchregOpRange($$dpth: number, $$cr?: ErrorTracker): Nullable<regOpRange> {
        return this.run<regOpRange>($$dpth,
            () => {
                let $scope$op1: Nullable<regOp>;
                let $scope$op2: Nullable<regOp>;
                let $$res: Nullable<regOpRange> = null;
                if (true
                    && ($scope$op1 = this.matchregOp($$dpth + 1, $$cr)) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:-)`, $$dpth + 1, $$cr) !== null
                    && this.matchwso($$dpth + 1, $$cr) !== null
                    && ($scope$op2 = this.matchregOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.regOpRange, op1: $scope$op1, op2: $scope$op2};
                }
                return $$res;
            });
    }
    public matchregOpOrRange($$dpth: number, $$cr?: ErrorTracker): Nullable<regOpOrRange> {
        return this.choice<regOpOrRange>([
            () => this.matchregOpOrRange_1($$dpth + 1, $$cr),
            () => this.matchregOpOrRange_2($$dpth + 1, $$cr),
        ]);
    }
    public matchregOpOrRange_1($$dpth: number, $$cr?: ErrorTracker): Nullable<regOpOrRange_1> {
        return this.run<regOpOrRange_1>($$dpth,
            () => {
                let $scope$op: Nullable<regOpRange>;
                let $$res: Nullable<regOpOrRange_1> = null;
                if (true
                    && ($scope$op = this.matchregOpRange($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.regOpOrRange_1, op: $scope$op};
                }
                return $$res;
            });
    }
    public matchregOpOrRange_2($$dpth: number, $$cr?: ErrorTracker): Nullable<regOpOrRange_2> {
        return this.run<regOpOrRange_2>($$dpth,
            () => {
                let $scope$op: Nullable<regOp>;
                let $$res: Nullable<regOpOrRange_2> = null;
                if (true
                    && ($scope$op = this.matchregOp($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.regOpOrRange_2, op: $scope$op};
                }
                return $$res;
            });
    }
    public matchshiftType($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftType> {
        return this.choice<shiftType>([
            () => this.matchshiftType_1($$dpth + 1, $$cr),
            () => this.matchshiftType_2($$dpth + 1, $$cr),
            () => this.matchshiftType_3($$dpth + 1, $$cr),
            () => this.matchshiftType_4($$dpth + 1, $$cr),
            () => this.matchshiftType_5($$dpth + 1, $$cr),
            () => this.matchshiftType_6($$dpth + 1, $$cr),
        ]);
    }
    public matchshiftType_1($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftType_1> {
        return this.regexAccept(String.raw`(?:[lL][sS][lL])`, $$dpth + 1, $$cr);
    }
    public matchshiftType_2($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftType_2> {
        return this.regexAccept(String.raw`(?:[aA][sS][lL])`, $$dpth + 1, $$cr);
    }
    public matchshiftType_3($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftType_3> {
        return this.regexAccept(String.raw`(?:[lL][sS][rR])`, $$dpth + 1, $$cr);
    }
    public matchshiftType_4($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftType_4> {
        return this.regexAccept(String.raw`(?:[aA][sS][rR])`, $$dpth + 1, $$cr);
    }
    public matchshiftType_5($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftType_5> {
        return this.regexAccept(String.raw`(?:[rR][oO][rR])`, $$dpth + 1, $$cr);
    }
    public matchshiftType_6($$dpth: number, $$cr?: ErrorTracker): Nullable<shiftType_6> {
        return this.regexAccept(String.raw`(?:[rR][rR][xX])`, $$dpth + 1, $$cr);
    }
    public matchcondition($$dpth: number, $$cr?: ErrorTracker): Nullable<condition> {
        return this.run<condition>($$dpth,
            () => {
                let $scope$condType: Nullable<conditionType>;
                let $scope$updateStatusReg: Nullable<Nullable<string>>;
                let $$res: Nullable<condition> = null;
                if (true
                    && ($scope$condType = this.matchconditionType($$dpth + 1, $$cr)) !== null
                    && (($scope$updateStatusReg = this.regexAccept(String.raw`(?:[sS])`, $$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.condition, condType: $scope$condType, updateStatusReg: $scope$updateStatusReg};
                }
                return $$res;
            });
    }
    public matchconditionType($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType> {
        return this.choice<conditionType>([
            () => this.matchconditionType_1($$dpth + 1, $$cr),
            () => this.matchconditionType_2($$dpth + 1, $$cr),
            () => this.matchconditionType_3($$dpth + 1, $$cr),
            () => this.matchconditionType_4($$dpth + 1, $$cr),
            () => this.matchconditionType_5($$dpth + 1, $$cr),
            () => this.matchconditionType_6($$dpth + 1, $$cr),
            () => this.matchconditionType_7($$dpth + 1, $$cr),
            () => this.matchconditionType_8($$dpth + 1, $$cr),
            () => this.matchconditionType_9($$dpth + 1, $$cr),
            () => this.matchconditionType_10($$dpth + 1, $$cr),
            () => this.matchconditionType_11($$dpth + 1, $$cr),
            () => this.matchconditionType_12($$dpth + 1, $$cr),
            () => this.matchconditionType_13($$dpth + 1, $$cr),
            () => this.matchconditionType_14($$dpth + 1, $$cr),
            () => this.matchconditionType_15($$dpth + 1, $$cr),
            () => this.matchconditionType_16($$dpth + 1, $$cr),
            () => this.matchconditionType_17($$dpth + 1, $$cr),
            () => this.matchconditionType_18($$dpth + 1, $$cr),
            () => this.matchconditionType_19($$dpth + 1, $$cr),
        ]);
    }
    public matchconditionType_1($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_1> {
        return this.regexAccept(String.raw`(?:[eE][qQ])`, $$dpth + 1, $$cr);
    }
    public matchconditionType_2($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_2> {
        return this.regexAccept(String.raw`(?:[nN][eE])`, $$dpth + 1, $$cr);
    }
    public matchconditionType_3($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_3> {
        return this.regexAccept(String.raw`(?:[hH][sS])`, $$dpth + 1, $$cr);
    }
    public matchconditionType_4($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_4> {
        return this.regexAccept(String.raw`(?:[cC][sS])`, $$dpth + 1, $$cr);
    }
    public matchconditionType_5($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_5> {
        return this.regexAccept(String.raw`(?:[lL][oO])`, $$dpth + 1, $$cr);
    }
    public matchconditionType_6($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_6> {
        return this.regexAccept(String.raw`(?:[cC][cC])`, $$dpth + 1, $$cr);
    }
    public matchconditionType_7($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_7> {
        return this.regexAccept(String.raw`(?:[mM][iI])`, $$dpth + 1, $$cr);
    }
    public matchconditionType_8($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_8> {
        return this.regexAccept(String.raw`(?:[pP][lL])`, $$dpth + 1, $$cr);
    }
    public matchconditionType_9($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_9> {
        return this.regexAccept(String.raw`(?:[vV][sS])`, $$dpth + 1, $$cr);
    }
    public matchconditionType_10($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_10> {
        return this.regexAccept(String.raw`(?:[vV][cC])`, $$dpth + 1, $$cr);
    }
    public matchconditionType_11($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_11> {
        return this.regexAccept(String.raw`(?:[hH][iI])`, $$dpth + 1, $$cr);
    }
    public matchconditionType_12($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_12> {
        return this.regexAccept(String.raw`(?:[lL][sS])`, $$dpth + 1, $$cr);
    }
    public matchconditionType_13($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_13> {
        return this.regexAccept(String.raw`(?:[gG][eE])`, $$dpth + 1, $$cr);
    }
    public matchconditionType_14($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_14> {
        return this.regexAccept(String.raw`(?:[lL][tT])`, $$dpth + 1, $$cr);
    }
    public matchconditionType_15($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_15> {
        return this.regexAccept(String.raw`(?:[gG][tT])`, $$dpth + 1, $$cr);
    }
    public matchconditionType_16($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_16> {
        return this.regexAccept(String.raw`(?:[lL][eE])`, $$dpth + 1, $$cr);
    }
    public matchconditionType_17($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_17> {
        return this.regexAccept(String.raw`(?:[aA][lL])`, $$dpth + 1, $$cr);
    }
    public matchconditionType_18($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_18> {
        return this.regexAccept(String.raw`(?:[nN][vV])`, $$dpth + 1, $$cr);
    }
    public matchconditionType_19($$dpth: number, $$cr?: ErrorTracker): Nullable<conditionType_19> {
        return this.regexAccept(String.raw`(?:)`, $$dpth + 1, $$cr);
    }
    public matchws($$dpth: number, $$cr?: ErrorTracker): Nullable<ws> {
        return this.regexAccept(String.raw`(?:[ \t]+)`, $$dpth + 1, $$cr);
    }
    public matchwso($$dpth: number, $$cr?: ErrorTracker): Nullable<wso> {
        return this.regexAccept(String.raw`(?:[ \t]*)`, $$dpth + 1, $$cr);
    }
    public matchnend($$dpth: number, $$cr?: ErrorTracker): Nullable<nend> {
        return this.choice<nend>([
            () => this.matchnend_1($$dpth + 1, $$cr),
            () => this.matchnend_2($$dpth + 1, $$cr),
        ]);
    }
    public matchnend_1($$dpth: number, $$cr?: ErrorTracker): Nullable<nend_1> {
        return this.regexAccept(String.raw`(?:\n)`, $$dpth + 1, $$cr);
    }
    public matchnend_2($$dpth: number, $$cr?: ErrorTracker): Nullable<nend_2> {
        return this.match$EOF($$cr);
    }
    public test(): boolean {
        const mrk = this.mark();
        const res = this.matchstart(0);
        const ans = res !== null;
        this.reset(mrk);
        return ans;
    }
    public parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchstart(0);
        if (res)
            return {ast: res, errs: []};
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.clearMemos();
        this.matchstart(0, rec);
        const err = rec.getErr()
        return {ast: res, errs: err !== null ? [err] : []}
    }
    public mark(): PosInfo {
        return this.pos;
    }
    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        for (;;) {
            const t = func();
            if (t === null) {
                break;
            }
            res.push(t);
        }
        if (star || res.length > 0) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn()
        if (res !== null)
            return res;
        this.reset(mrk);
        return null;
    }
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, dpth: number, cr?: ErrorTracker): Nullable<string> {
        return this.run<string>(dpth,
            () => {
                const reg = new RegExp(match, "y");
                const mrk = this.mark();
                reg.lastIndex = mrk.overallPos;
                const res = this.tryConsume(reg);
                if(cr) {
                    cr.record(mrk, res, {
                        kind: "RegexMatch",
                        // We substring from 3 to len - 1 to strip off the
                        // non-capture group syntax added as a WebKit workaround
                        literal: match.substring(3, match.length - 1),
                        negated: this.negating,
                    });
                }
                return res;
            });
    }
    private tryConsume(reg: RegExp): Nullable<string> {
        const res = reg.exec(this.input);
        if (res) {
            let lineJmp = 0;
            let lind = -1;
            for (let i = 0; i < res[0].length; ++i) {
                if (res[0][i] === "\n") {
                    ++lineJmp;
                    lind = i;
                }
            }
            this.pos = {
                overallPos: reg.lastIndex,
                line: this.pos.line + lineJmp,
                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)
            };
            return res[0];
        }
        return null;
    }
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {
        const $scope$pos = this.mark();
        const $scope$memoRes = memo.get($scope$pos.overallPos);
        if(this.memoSafe && $scope$memoRes !== undefined) {
        this.reset($scope$memoRes[1]);
        return $scope$memoRes[0];
        }
        const $scope$result = rule();
        if(this.memoSafe)
        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);
        return $scope$result;
    }
    private match$EOF(et?: ErrorTracker): Nullable<{kind: ASTKinds.$EOF}> {
        const res: {kind: ASTKinds.$EOF} | null = this.finished() ? { kind: ASTKinds.$EOF } : null;
        if(et)
            et.record(this.mark(), res, { kind: "EOF", negated: this.negating });
        return res;
    }
}
export function parse(s: string): ParseResult {
    const p = new Parser(s);
    return p.parse();
}
export interface ParseResult {
    ast: Nullable<start>;
    errs: SyntaxErr[];
}
export interface PosInfo {
    readonly overallPos: number;
    readonly line: number;
    readonly offset: number;
}
export interface RegexMatch {
    readonly kind: "RegexMatch";
    readonly negated: boolean;
    readonly literal: string;
}
export type EOFMatch = { kind: "EOF"; negated: boolean };
export type MatchAttempt = RegexMatch | EOFMatch;
export class SyntaxErr {
    public pos: PosInfo;
    public expmatches: MatchAttempt[];
    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {
        this.pos = pos;
        this.expmatches = [...expmatches];
    }
    public toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === "EOF" ? " EOF" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;
    }
}
class ErrorTracker {
    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};
    private regexset: Set<string> = new Set();
    private pmatches: MatchAttempt[] = [];
    public record(pos: PosInfo, result: any, att: MatchAttempt) {
        if ((result === null) === att.negated)
            return;
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.pmatches = [];
            this.regexset.clear()
        }
        if (this.mxpos.overallPos === pos.overallPos) {
            if(att.kind === "RegexMatch") {
                if(!this.regexset.has(att.literal))
                    this.pmatches.push(att);
                this.regexset.add(att.literal);
            } else {
                this.pmatches.push(att);
            }
        }
    }
    public getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1)
            return new SyntaxErr(this.mxpos, this.pmatches);
        return null;
    }
}